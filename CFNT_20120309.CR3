''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' REgional Approaches to Climate CHange 
' Laboratory for Atmospheric Research
' Washington State University
'
' Site: Cook Farm No-Till
' Description: This program combines fast measurements of CO2 and H2O with 3D wind speeds  
'   to generate near real-time surface fluxes of CO2, latent & sensible heat. Additional 
'   meteorological statistics are produced in five and thirty minute intervals. 
' 
'TODO 
' - reverse occurances of EC150 & EC100 b/c to prevent using the irga model name to describe
'   irga+csat system & vice-versa
' - add sensor input constants for MetOne WS/WD, Rain Pulse counters, etc
' - remove sensors we did not and will not purchase
' - create a lean 10hz table for rapid download
' - add azimiuth for cup & vane 
'
'Version history
' 20120309 [pto]
'   - (!) fixed bug where 5 min stats were used for both 5/30min derived HMP values (e/esat/RH)
' 20120215 [pto]
'   - std_wnd_dir reports 0 sometimes; completely unapparent why
'     > WindVector ignores NANs for stddev and "for Option output 2" (CSI CRBASIC help)
'     > introduced sonic_uptime (0-1) signifying ratio of good samples out of possible
'     > code now sets all results of WindVector to NAN if sonic_uptime < 0.5
'   - when no sonic values are recorded (flags=100%) the recorded wind dir is the azimuth
'     > solved by introducing sonic_uptime variable; set to NAN when uptime < 0.5
'   - T_hmp is 0, RH_hmp_Avg is NAN throughout 5,30min files
'     > inserted missing GetRecord() statement into both HMP stat processing blocks
'   - CO2_ppm_Avg (based on Xc) is nonzero when remaining IRGA values are NAN
'     > use analogous irga_uptime to set Xc,Xv=NAN when uptime < 0.5
'   - applied *_uptime variables to all csat/irga intermediate processing 
'   - streamlined csat/irga diagnostic handling since flags are no longer totaled
'   - added stddev of CO2_ppm, mean+stdev of H2O in g/kg, mean amb_tmpr to stats tables 
'   - (!) set Met1 WS multiplier to value in manual (0.799 -> 0.7989)
'   - changed conditionals regarding MetOne so WS=0 -> NAN, bad WDs = NAN
'   - (!) changed constant SITE_PRESS to 93.5 kPa based data from Dec 2011 - Feb 2012
'   - made most variables public to facilitate troubleshooting
' 20120210 [pto]
'   - begin commenting unused conditional compilation blocks
'   - begin applying consistent naming scheme to constants and variables
'   - disabled System Control menu for lack of apparent utility
'   - added disable flags to prevent NAN output for LI-190SB, 034B, TE525
'   - (!) changed wind vector calculation for 034B from type 0 to 2 to match csat
'   - (!) removed erroreous mixing ratio calculations -> use Xc, Xv
'   - (!) relocated Monin-Obukhov length calculation so it uses correct Tc_mean
'   - moved HMP mult/offsets into voltdiff() statements, added them for RH channel
'   - (!) implemented back-end to get correct 5min statistics
'   - changed NR Lite measurement from AutoRange to mV20
'   - encountered compilation bug which prevents duplicate FieldName assignments, even
'     in different data tables; implemented separate data tables for 034B to permit
'     same field names in output tables; also renamed '034B' to 'Met1'
'   - force nearly all tables to autoallocate now
'   - added (dry) mixing ratio to 5/30min outputs
' 20120204  [pto, patrick.okeeffe@email.wsu.edu]
'   - copy 30min flux table as a 5min flux table, removed extra variables, ensure units for each
'     variable, no correctness checks
'   - start file naming scheme
'   - enclose sensor statements in compilation conditionals to match original style
'   - relocated ANAL0G_INTEGRATION constant from sensor input mapping to program variable setup
' ....
' backfill?
' ...
' 20110216  version 3.0
'   Copyright (c) 2002, 2006, 2010 Campbell Scientific, Inc. All rights reserved.
'
' Flux sign convention is positive upwards, away from the surface and negative downwards, 
' towards the surface. Before computing online fluxes, the datalogger will introduce lags 
' into the eddy covariance data to account for the fixed instrument delays. The lags are
' dependent on the instrument setting and/or the scan interval. Search for "Fixed inherent 
' lag" and set the delay to the appropriate value. The raw data is not lagged. The site 
' attendant must load in several constants and calibration values. Search for the text string 
' "unique" to find the locations where unique constants and calibration values are entered.
'   
'C        Celsius
'degrees  degrees (angle)
'g        grams
'J        Joules
'kg       kilograms
'kPa      kilopascals
'm        meters
'mg       milligrams
'mmol     millimoles
'mol      moles
's        seconds
'umol     micromols
'V        volts
'W        Watts


'== REACCH SENSOR CONFIGURATION ==
Const SENSOR_EC150       = TRUE  'EC150/CSAT3A    OP-IRGA & 3d sonic anemometer/thermometer
Const SENSOR_HMP         = TRUE  'HMP155A/HMP45C  temperature and relative humidity
Const SENSOR_NR_LITE     = TRUE  'NR Lite         net radiometer
Const SENSOR_190SB       = TRUE  'LI190SB         licor quantum sensor??
Const SENSOR_034B        = TRUE  '034B            cup & vane
Const SENSOR_TE525       = TRUE  'TE525           texas instruments rain gage


'== OPTIONAL DEPLOYMENT SENSORS 
Const SENSOR_N2O         = FALSE  'Los Gatos N2O/CO analyzer
Const SENSOR_CH4         = FALSE  'Picarro CO2/CH4/H2O analyzer
Const SENSOR_5TM         = FALSE  '5TM             decagon soil temp/moisture probe
Const SENSOR_HFP01       = FALSE  'HFP01           soil heat flux plates


'== SENSORS NOT USED ==
Const SENSOR_Q7_1        = FALSE  'Q7.1            net radiometer
Const SENSOR_CNR_2       = FALSE  'CNR 2           net radiometer
Const SENSOR_NR_01_CNR_1 = FALSE  'NR 01/CNR 1     net radiometer
Const SENSOR_CNR_4       = FALSE  'CNR 4           net radiometer
Const SENSOR_TCAV        = FALSE  'TCAV            type E thermocouple averaging soil temperature probes
Const SENSOR_CS616       = FALSE  'CS616           water content reflectometers (volumetric soil moisture)
Const SENSOR_HFT3        = FALSE  'HFT3            soil heat flux plates
Const SENSOR_HFP01SC     = FALSE  'HFP01SC         soil heat flux plates



'== SENSOR INPUT MAP ==

#If ( SENSOR_EC150 = TRUE ) Then
  Const EC100_SDM_ADDR = 1               'Unique SDM address for EC100.
#EndIf


#If ( SENSOR_HMP = TRUE ) Then
  Const HMP_ANALOG_T_INPUT = 2             'Unique analog input channel.
  Const HMP_ANALOG_RH_INPUT = 3           'Unique: HMP RH input
#EndIf


#If ( SENSOR_Q7_1 = TRUE ) Then
  Const NR_ANALOG_INPUT = 4              'Unique analog input channel.
#EndIf


#If ( SENSOR_NR_LITE = TRUE ) Then
  Const NR_ANALOG_INPUT = 4              'Unique analog input channel.
#EndIf


#If ( SENSOR_CNR_2 = TRUE ) Then
  Const NR_ANALOG_INPUT = 4              'Unique analog input channel.
#EndIf


#If ( SENSOR_NR_01_CNR_1 = TRUE ) Then
  Const T_NR_ANALOG_INPUT = 1            'Unique analog input channel.
  Const NR_ANALOG_INPUT = 2              'Unique analog input channel.
#EndIf


#If ( SENSOR_CNR_4 = TRUE ) Then
  Const T_NR_ANALOG_INPUT = 1            'Unique analog input channel.
  Const NR_ANALOG_INPUT = 2              'Unique analog input channel.
#EndIf


#If ( SENSOR_CS616 = TRUE ) Then
  Const CS616_ANALOG_INPUT = 11          'Unique analog input channel.
#EndIf


#If ( SENSOR_TCAV = TRUE ) Then
  Const TCAV_ANALOG_INPUT = 7            'Unique analog input channel.
#EndIf


#If ( SENSOR_HFT3 = TRUE ) Then
  Const SHF_ANALOG_INPUT = 9            'Unique analog input channel.
#EndIf


#If ( SENSOR_HFP01 = TRUE ) Then
  Const SHF_ANALOG_INPUT = 9           'Unique analog input channel.
#EndIf


#If ( SENSOR_HFP01SC = TRUE ) Then
  Const SHF_ANALOG_INPUT = 9             'Unique analog input channel.
  Const SHF_HEATER_ANALOG_INPUT = 25     'Unique analog input channel.
#EndIf
 
#If ( SENSOR_5TM = TRUE ) Then
  Const 5tm_sdi_input = 1             'Unique sdi input channel.
#EndIf


Const PAR_ANALOG_INPUT = 5             'Unique: PAR diff input chan #

#If ( SENSOR_034B = TRUE ) Then
  Const WIND_034B_SE_INPUT = 11          'Unique: 034B single ended input = D6H
#EndIf

PipeLineMode

'*** General constants and variables ***
Const FAST_RATE = 100  		'Unique: length of primary scan interval, ms
Const STAT_INT1 = 5   		'Unique: flux data output interval (1), min
Const STAT_INT2 = 30		  'Unique: flux data output interval (2), min

Const SDM_PER = 30          'Unique: default SDM clock speed
Const A_INTEG = _60Hz       'Slowsequence analog measurement integration time, _60Hz or _50Hz.

Const OFFSET = 17           'minimum # of records req'd to compensate for IRGA/CSAT lags on-the-fly
Const SCAN_BUFFER_SIZE = 60*INT (1000/FAST_RATE)     'Compute a 60 second scan buffer.
'Const NUM_DAY_CPU = 7                                    'Number of days of data to store on the CPU.
'Const FLUX_SIZE_CPU = (NUM_DAY_CPU*1440)/STAT_INT1 'Size of flux data table on CPU [days].

Const MU_WPL = 29/18                                     'Ratio of the molecular weight of dry air to that of water vapor.
Const R = .0083143                                      'Universal gas constant [kPa m^3/(K mol)].
Const RD = R/29                                          'Gas constant for dry air [kPa m^3/(K g)].
Const LV = 2440                                          'Estimate of the latent heat of vaporization [J/g].
Const RV = R/18                                          'Gas constant for water vapor [kPa m^3/(K g)].

Dim dly_data_out(7)                                      'Array used to temporarily store the lagged record.

'Other measurements.
Public panel_tmpr
Public batt_volt
Units panel_tmpr = C
Units batt_volt = V
'Public co2_mix_ratio
'Public co2_molar_density
'Public h2o_mix_ratio
'Public h2o_molar_density
Public L
Units L = m

'Program working variables.
Dim scan_count As Long                                   'Number scans executed.
Dim slowsequence_finished_f As Boolean                   'Flag used to indicate the SlowSequence has finished its scan.
Dim slowsequence_disable_f As Boolean = {TRUE}           'Flag used to decimate statistics in main scan.
Dim sys_conf_var_file As Long                            'Filehandle for the file that contains the system configuration variables in the CPU.
Dim i As Long                                            'Main scan index variable.
Dim ii As Long                                           'Slow sequence scan index variable.
Dim n = {1}
Units n = samples

Public min_uptime = {0.5}         'minimum ratio of OK samples in total to enable stats





#If ( SENSOR_EC150 = TRUE ) Then
'*** Beginning of EC100 configure, zero, and span constants and variables, and subroutine ***
Const BANDWIDTH = 20            '20 = 20 Hz
Const DIFFERENTIAL_PRESSURE = 0 '0 = disabled
Const TEMPERATURE_SOURCE = 0    '0 = ambient temperature sensor
Const BB = 0                    'BB = EC100 basic pressure transducer
Const EB = 2                    'EB = EC100 enhanced pressure transducer

Public CO2_span_gas
Public Td_span_gas

Dim config_array(3,2) = {0,BANDWIDTH,3,DIFFERENTIAL_PRESSURE,7,TEMPERATURE_SOURCE}
Dim press_source_array(1,2) = {2,0}   'Pressure source,basic pressure transducer (default).
Dim zero_array(1,2) = {11,1}          'Zero/Span command,set zero value.
Dim span_CO2_array(2,2) = {12,0,11,2} 'CO2 span concentration,0; Zero/Span command,set CO2 span value (default).
Dim span_H2O_array(2,2) = {13,0,11,3} 'H2O span dew point temperature,0; Zero/Span command,set H2O span value (default).

Public set_press_source_f As Boolean
Public do_zero_f As Boolean
Public do_CO2_span_f As Boolean
Public do_H2O_span_f As Boolean
Dim configure_ec100_f As Boolean = {TRUE}
Dim NAN_cnt As Long
Dim retry_config_f As Boolean


Sub Config (cmd_array(4,2),num_cmd As Long,retry_config_f As Boolean)
  Dim i As Long
  Dim config_result As Long
  Dim save_flash_f As Boolean = {FALSE}

  For i = 1 To num_cmd
    EC100Configure (config_result,1,cmd_array(i,1),cmd_array(i,2))
    If ( config_result = NAN ) Then ( ExitFor )
    If ( (cmd_array(i,1) = 2) OR (cmd_array(i,1) = 11) ) Then ( save_flash_f = TRUE )
  Next i

  If ( i = num_cmd+1 ) Then
    If ( save_flash_f ) Then ( EC100Configure (config_result,EC100_SDM_ADDR,99,2718) )
    If ( config_result <> NAN ) Then ( retry_config_f = FALSE )
  EndIf

  SetStatus ("SkippedScan",0)
EndSub
'*** End of EC100 configure, zero, and span constants and variables, and subroutine ***
#EndIf


#If ( SENSOR_EC150 = TRUE ) Then
'*** Beginning of CSAT3A sonic head constants, variables, and working data table ***
Const CP = 1004.67                         'Estimate of heat capacity of air [J/(kg K)].

Dim sonic_irga_raw(12)                     'unlagged EC150 irga + CSAT3A sonic data

Public sonic(5)                            'lagged working CSAT3A data
Alias sonic(1) = Ux
Alias sonic(2) = Uy
Alias sonic(3) = Uz
Alias sonic(4) = Ts
Alias sonic(5) = diag_sonic
Units sonic = m/s
Units Ts = C
Units diag_sonic = bitmap

Public Ts_absolute                         'Sonic temperature (K)
Public sonic_azimuth                       'CSAT3A azimuth & prev
Dim sonic_azimuth_prev
Units Ts_absolute = Kelvin
Units sonic_azimuth = degrees
Units sonic_azimuth_prev = degrees

'Public diag_bits_sonic(6) As Boolean       'Sonic warning flags.
'Alias diag_bits_sonic(1) = amp_l_f         'Amplitude low warning flag.
'Alias diag_bits_sonic(2) = amp_h_f         'Amplitude high warning flag.
'Alias diag_bits_sonic(3) = sig_lck_f       'Poor signal lock warning flag.
'Alias diag_bits_sonic(4) = del_T_f         'Delta temperature warning flag.
'Alias diag_bits_sonic(5) = aq_sig_f        'Sonic acquiring signals warning flag.
'Alias diag_bits_sonic(6) = sonic_cal_err_f 'Signature error in reading CSAT3A sonic head calibration data.
'Units diag_bits_sonic = samples

Dim diag_sonic_tmp As Long                 'Temporary variable used to break out the CSAT3A sonic head diagnostic bits.
Dim sonic_disable_f As Boolean             'TRUE if CSAT3A diag warning flag, SDM error or no data

Dim cov_array_sonic(1,4)                   'Arrays used to hold the input data for the covariance instructions (CSAT3A sonic head).

Public cov_out_sonic(22)                   'CSAT3A sonic head statistics.
Alias cov_out_sonic(1) = Hs                'Sensible heat flux using sonic temperature.
Alias cov_out_sonic(2) = tau               'Momentum flux.
Alias cov_out_sonic(3) = u_star            'Friction velocity.
Alias cov_out_sonic(4) = Ts_stdev          'results of covariance instructions, 10 qntys
Alias cov_out_sonic(5) = Ts_Ux_cov
Alias cov_out_sonic(6) = Ts_Uy_cov
Alias cov_out_sonic(7) = Ts_Uz_cov
Alias cov_out_sonic(8) = Ux_stdev
Alias cov_out_sonic(9) = Ux_Uy_cov
Alias cov_out_sonic(10) = Ux_Uz_cov
Alias cov_out_sonic(11) = Uy_stdev
Alias cov_out_sonic(12) = Uy_Uz_cov
Alias cov_out_sonic(13) = Uz_stdev
Alias cov_out_sonic(14) = wnd_spd          'results of windvector instruction, 4 qntys
Alias cov_out_sonic(15) = rslt_wnd_spd
Alias cov_out_sonic(16) = wnd_dir_sonic
Alias cov_out_sonic(17) = std_wnd_dir
Alias cov_out_sonic(18) = Ts_Avg
Alias cov_out_sonic(19) = sonic_samples     'result of first totalize instruction
Alias cov_out_sonic(20) = sonic_possible    'result of 2nd totalize
Alias cov_out_sonic(21) = sonic_uptime
Alias cov_out_sonic(22) = wnd_dir_compass
Units Hs = W/m^2
Units tau = kg/(m s^2)
Units u_star = m/s
Units Ts_stdev = C
Units Ts_Ux_cov = C m/s
Units Ts_Uy_cov = C m/s
Units Ts_Uz_cov = C m/s
Units Ux_stdev = m/s
Units Ux_Uy_cov = (m/s)^2
Units Ux_Uz_cov = (m/s)^2
Units Uy_stdev = m/s
Units Uy_Uz_cov = (m/s)^2
Units Uz_stdev = m/s
Units wnd_spd = m/s
Units rslt_wnd_spd = m/s
Units wnd_dir_sonic = degrees
Units std_wnd_dir = degrees
Units Ts_Avg = C
Units sonic_uptime = unity
Units wnd_dir_compass = degrees

DataTable (work_delay_csat,TRUE,OFFSET)
  TableHide
  Sample (5,sonic_irga_raw(1),IEEE4)
EndTable

DataTable (work_cov1_csat,TRUE,1)
'  TableHide
  DataInterval (0,STAT_INT1,Min,1)
  Covariance (4,cov_array_sonic(1,1),IEEE4,sonic_disable_f,10)
  WindVector (1,Uy,Ux,IEEE4,sonic_disable_f,0,1,2)
  Average(1,Ts,IEEE4,sonic_disable_f) 
  Totalize (1,n,IEEE4,sonic_disable_f)
    FieldNames("sonic_samples_Tot")
  Totalize (1,n,IEEE4,FALSE)
    FieldNames("sonic_possible_Tot")
EndTable

DataTable (work_cov2_csat,TRUE,1)
'  TableHide
  DataInterval (0,STAT_INT2,Min,1)
  Covariance (4,cov_array_sonic(1,1),IEEE4,sonic_disable_f,10)
  WindVector (1,Uy,Ux,IEEE4,sonic_disable_f,0,1,2)
  Average(1,Ts,IEEE4,sonic_disable_f)    
  Totalize (1,n,IEEE4,sonic_disable_f)
    FieldNames("sonic_samples_Tot")
  Totalize (1,n,IEEE4,FALSE)
    FieldNames("sonic_possible_Tot")
EndTable


'*** Beginning of EC150 constants, variables, and working data table ***
Const DELAY_EC150 = INT (4000/FAST_RATE/BANDWIDTH) 'Automatically computed lag of the EC150 data.
Const EC150_REC_BCK = OFFSET-DELAY_EC150 'Number of records back to align EC150 data.

Public irga(9)
Alias irga(1) = CO2
Alias irga(2) = H2O
Alias irga(3) = diag_irga
Alias irga(4) = amb_tmpr
Alias irga(5) = amb_press
Alias irga(6) = CO2_sig_strgth
Alias irga(7) = H2O_sig_strgth
Alias irga(8) = Tc
Alias irga(9) = Td
Units CO2 = mg/m^3
Units H2O = g/m^3
Units diag_irga = bitmap
Units amb_tmpr = C
Units amb_press = kPa
Units CO2_sig_strgth = unity
Units H2O_sig_strgth = unity
Units Tc = C
Units Td = C

'Public diag_bits_irga(21) As Boolean        'Gas analyzer warning flags.
'Alias diag_bits_irga(1) = irga_bad_data_f   'EC150 bad data warning flag.
'Alias diag_bits_irga(2) = gen_sys_fault_f   'General system fault warning flag.
'Alias diag_bits_irga(3) = sys_startup_f     'EC150 starting up warning flag.
'Alias diag_bits_irga(4) = motor_spd_f       'EC150 motor speed out of bounds warning flag.
'Alias diag_bits_irga(5) = tec_tmpr_f        'Thermoelectric cooler temperature out of bounds warning flag.
'Alias diag_bits_irga(6) = src_pwr_f         'EC150 source power out of bounds warning flag.
'Alias diag_bits_irga(7) = src_tmpr_f        'EC150 source temperature out of bounds warning flag.
'Alias diag_bits_irga(8) = src_curr_f        'EC150 source current out of bounds warning flag.
'Alias diag_bits_irga(9) = irga_off_f        'Gas analyzer head is powered down.
'Alias diag_bits_irga(10) = irga_sync_f      'EC150 not synchronized with home pulse warning flag.
'Alias diag_bits_irga(11) = amb_tmpr_f       'Invalid ambient temperature warning flag.
'Alias diag_bits_irga(12) = amb_press_f      'Invalid ambient pressure warning flag.
'Alias diag_bits_irga(13) = CO2_I_f          'CO2 I out of bounds warning flag.
'Alias diag_bits_irga(14) = CO2_Io_f         'CO2 Io out of bounds warning flag.
'Alias diag_bits_irga(15) = H2O_I_f          'H2O I out of bounds warning flag.
'Alias diag_bits_irga(16) = H2O_Io_f         'H2O Io out of bounds warning flag.
'Alias diag_bits_irga(17) = CO2_Io_var_f     'CO2 Io moving variation out of bounds warning flag.
'Alias diag_bits_irga(18) = H2O_Io_var_f     'H2O Io moving variation out of bounds warning flag.
'Alias diag_bits_irga(19) = CO2_sig_strgth_f 'CO2 signal strength warning flag.
'Alias diag_bits_irga(20) = H2O_sig_strgth_f 'H2O signal strength warning flag.
'Alias diag_bits_irga(21) = irga_cal_err_f   'EC150 calibration data signature error.
'Units diag_bits_irga = samples

Public Xc                                   'CO2 molar mixing ratio.
Public Xv                                   'H2O molar mixing ratio.
Dim divisor                                 'Temporary variable used to find molar mixing ratio.
Dim diag_irga_tmp As Long                   'Temporary variable used to break out the EC150 diagnostic bits.
Dim irga_disable_f As Boolean               'TRUE when EC150 sends bad data.
Public rho_d_mean                              'Density of dry air used in Webb et al. term [kg / m^3].
Public sigma_wpl                               'Webb et al. sigma = density of water vapor / density of dry air.
Dim mask As Long
Dim Td_tmp
Units Xc = umol/mol
Units Xv = mmol/mol

Dim cov_array_cs(3,4)                       'Arrays used to hold the input data for the covariance instructions (sonic and EC150).
Public cov_out_cs(34)                          'EC150 statistics.
Alias cov_out_cs(1) = Fc_wpl                'Carbon dioxide flux (EC150), with Webb et al. term.
Alias cov_out_cs(2) = LE_wpl                'Latent heat flux (EC150), with Webb et al. term.
Alias cov_out_cs(3) = Hc                    'Sensible heat flux using sonic temperature corrected for water vapor measured by the EC150.
Alias cov_out_cs(4) = CO2_stdev
Alias cov_out_cs(5) = CO2_Ux_cov
Alias cov_out_cs(6) = CO2_Uy_cov
Alias cov_out_cs(7) = CO2_Uz_cov
Alias cov_out_cs(8) = H2O_stdev
Alias cov_out_cs(9) = H2O_Ux_cov
Alias cov_out_cs(10) = H2O_Uy_cov
Alias cov_out_cs(11) = H2O_Uz_cov
Alias cov_out_cs(12) = Tc_stdev
Alias cov_out_cs(13) = Tc_Ux_cov
Alias cov_out_cs(14) = Tc_Uy_cov
Alias cov_out_cs(15) = Tc_Uz_cov
Alias cov_out_cs(16) = CO2_ppm_Avg
Alias cov_out_cs(17) = H2O_g_kg_Avg
Alias cov_out_cs(18) = CO2_mean
Alias cov_out_cs(19) = H2O_mean
Alias cov_out_cs(20) = amb_press_mean
Alias cov_out_cs(21) = amb_tmpr_Avg
Alias cov_out_cs(22) = Tc_mean              'Sonic temperature corrected for humidity.
Alias cov_out_cs(23) = CO2_signal_Avg
Alias cov_out_cs(24) = H2O_signal_Avg
Alias cov_out_cs(25) = irga_samples
Alias cov_out_cs(26) = irga_possible
Alias cov_out_cs(27) = irga_uptime
Alias cov_out_cs(28) = rho_a_mean
Alias cov_out_cs(29) = Fc_irga              'Carbon dioxide flux (EC150), without Webb et al. term.
Alias cov_out_cs(30) = LE_irga              'Latent heat flux (EC150), without Webb et al. term.
Alias cov_out_cs(31) = CO2_wpl_LE           'Carbon dioxide flux (EC150), Webb et al. term due to latent heat flux.
Alias cov_out_cs(32) = CO2_wpl_H            'Carbon dioxide flux (EC150), Webb et al. term due to sensible heat flux.
Alias cov_out_cs(33) = H2O_wpl_LE           'Latent heat flux (EC150), Webb et al. term due to latent heat flux.
Alias cov_out_cs(34) = H2O_wpl_H            'Latent heat flux (EC150), Webb et al. term due to sensible heat flux.
Units Fc_wpl = mg/(m^2 s)
Units LE_wpl = W/m^2
Units Hc = W/m^2
Units CO2_stdev = mg/m^3
Units CO2_Ux_cov = mg/(m^2 s)
Units CO2_Uy_cov = mg/(m^2 s)
Units CO2_Uz_cov = mg/(m^2 s)
Units H2O_stdev = g/m^3
Units H2O_Ux_cov = g/(m^2 s)
Units H2O_Uy_cov = g/(m^2 s)
Units H2O_Uz_cov = g/(m^2 s)
Units Tc_stdev = C
Units Tc_Ux_cov = C m/s
Units Tc_Uy_cov = C m/s
Units Tc_Uz_cov = C m/s
Units CO2_ppm_Avg = ppm
Units H2O_g_kg_Avg = g_kg
Units CO2_mean = mg/m^3
Units H2O_mean = g/m^3
Units amb_tmpr_Avg = C
Units amb_press_mean = kPa
Units Tc_mean = C
Units CO2_signal_Avg = ratio
Units H2O_signal_Avg = ratio
Units irga_samples = samples
Units irga_possible = samples
Units irga_uptime = ratio
Units rho_a_mean = kg/m^3
Units Fc_irga = mg/(m^2 s)
Units LE_irga = W/m^2
Units CO2_wpl_LE = mg/(m^2 s)
Units CO2_wpl_H = mg/(m^2 s)
Units H2O_wpl_LE = W/m^2
Units H2O_wpl_H = W/m^2

DataTable (work_delay_irga,TRUE,OFFSET)
  TableHide
  Sample (7,sonic_irga_raw(6),IEEE4)
EndTable

DataTable (work_cov1_irga,TRUE,1)
'  TableHide
  DataInterval (0,STAT_INT1,Min,1)
  Covariance (4,cov_array_cs(1,1),IEEE4,irga_disable_f,4)
  Covariance (4,cov_array_cs(2,1),IEEE4,irga_disable_f,4)
  Covariance (4,cov_array_cs(3,1),IEEE4,irga_disable_f,4)
  Average (1,Xc,IEEE4,irga_disable_f)
  Average (1,(Xv / MU_WPL),IEEE4,irga_disable_f)
  Average (2,CO2,IEEE4,irga_disable_f)
  Average (1,amb_press,IEEE4,irga_disable_f)
  Average(1,amb_tmpr,IEEE4,(irga_disable_f OR amb_tmpr=NAN))
  Average (1,Tc,IEEE4,irga_disable_f)
  Average (1,CO2_sig_strgth,IEEE4,irga_disable_f)
  Average (1,H2O_sig_strgth,IEEE4,irga_disable_f)
  Totalize (1,n,IEEE4,irga_disable_f)
    FieldNames("irga_samples_Tot")
  Totalize (1,n,IEEE4,FALSE)
    FieldNames("irga_possible_Tot")
EndTable

DataTable (work_cov2_irga,TRUE,1)
'  TableHide
  DataInterval (0,STAT_INT2,Min,1)
  Covariance (4,cov_array_cs(1,1),IEEE4,irga_disable_f,4)
  Covariance (4,cov_array_cs(2,1),IEEE4,irga_disable_f,4)
  Covariance (4,cov_array_cs(3,1),IEEE4,irga_disable_f,4)
  Average (1,Xc,IEEE4,irga_disable_f)
  Average (1,(Xv / MU_WPL),IEEE4,irga_disable_f)
  Average (2,CO2,IEEE4,irga_disable_f)
  Average (1,amb_press,IEEE4,irga_disable_f)
  Average(1,amb_tmpr,IEEE4,(irga_disable_f OR amb_tmpr=NAN))
  Average (1,Tc,IEEE4,irga_disable_f)
  Average (1,CO2_sig_strgth,IEEE4,irga_disable_f)
  Average (1,H2O_sig_strgth,IEEE4,irga_disable_f)
  Totalize (1,n,IEEE4,irga_disable_f)
    FieldNames("irga_samples_Tot")
  Totalize (1,n,IEEE4,FALSE)
    FieldNames("irga_possible_Tot")
EndTable

'DisplayMenu ("System Control",TRUE)
'  MenuItem ("Sonic Azmth",sonic_azimuth)
'  'MenuItem ("ati azmth",ati_azimuth)
'  SubMenu ("Change Press Source")
'    MenuItem ("Select Srce",press_source_array(1,2))
'  MenuPick (BB,EB)
'    MenuItem ("Set Source",set_press_source_f)
'  MenuPick (True)
'  EndSubMenu
'  SubMenu ("On Site Zero & Span")
'    SubMenu ("Span Concentrations")
'      MenuItem ("CO2",CO2_span_gas)
'      MenuItem ("Td",Td_span_gas)
'    EndSubMenu
'    MenuItem ("Do Zero",do_zero_f)
'  MenuPick (True)
'    MenuItem ("Do CO2 Span",do_CO2_span_f)
'  MenuPick (True)
'    MenuItem ("Do H2O Span",do_H2O_span_f)
'  MenuPick (True)
'    DisplayValue ("CO2 um/m dry",Xc)
'    DisplayValue ("H2O mm/m dry",Xv)
'    DisplayValue ("Td degrees C",Td)
'  EndSubMenu
'EndMenu
#EndIf


#If ( SENSOR_HMP = TRUE ) Then
Const HMP_T_MULT = 0.14               'Unique multiplier for temperature; HMP155A = 0.14 or HMP45C = 0.1.
Const HMP_T_OFFSET = -80              'Unique offset for temperature;  HMP155A = -80 or HMP45C = -40.
Const HMP_RH_MULT = 0.1
Const HMP_RH_OFFSET = 0

Public hmp(3)
Alias hmp(1) = T_hmp                  'HMP temperature.
Alias hmp(2) = RH_hmp                 'HMP relative humidity.
Alias hmp(3) = e_hmp                  'HMP vapor pressure.
Units T_hmp = C
Units RH_hmp = percent
Units e_hmp = kPa

Public e_sat_hmp                         'HMP saturation vapor pressure.
Public rho_d_mean_hmp                    'Density of dry air used in Webb et al. term [kg / m^3]

Public cov_out_hmp(7)                    'HMP statistics.
Alias cov_out_hmp(1) = T_hmp_mean     'Mean HMP temperature.
Alias cov_out_hmp(2) = e_hmp_mean     'Mean HMP vapor pressure.
Alias cov_out_hmp(3) = e_sat_hmp_mean 'Mean HMP saturation vapor pressure.
Alias cov_out_hmp(4) = hmp_uptime     'ratio of good samples out of total
Alias cov_out_hmp(5) = H2O_hmp_mean   'Mean HMP vapor density.
Alias cov_out_hmp(6) = RH_hmp_mean    'Mean HMP relative humidity.
Alias cov_out_hmp(7) = rho_a_mean_hmp 'Mean air density using HMP measurements.
Units T_hmp_mean = C
Units e_hmp_mean = kPa
Units e_sat_hmp_mean = kPa
Units H2O_hmp_mean = g/m^3
Units RH_hmp_mean = %
Units rho_a_mean_hmp = kg/m^3

DataTable (work_stats1_hmp,TRUE,1)
'  TableHide
  DataInterval (0,STAT_INT1,Min,1)
  Average (1,T_hmp,IEEE4,(slowsequence_disable_f OR T_hmp=NAN))
  Average (1,e_hmp,IEEE4,(slowsequence_disable_f OR e_hmp=NAN))
  Average (1,e_sat_hmp,IEEE4,(slowsequence_disable_f OR e_sat_hmp=NAN))
EndTable

DataTable (work_stats2_hmp,TRUE,1)
'  TableHide
  DataInterval (0,STAT_INT1,Min,1)
  Average (1,T_hmp,IEEE4,(slowsequence_disable_f OR T_hmp=NAN))
  Average (1,e_hmp,IEEE4,(slowsequence_disable_f OR e_hmp=NAN))
  Average (1,e_sat_hmp,IEEE4,(slowsequence_disable_f OR e_sat_hmp=NAN))
EndTable

Const SITE_PRESS = 93.5            'Unique: user-defined site pressure (kpa?)
#EndIf


'#If ( SENSOR_Q7_1 = TRUE ) Then
''*** Beginning of Q7.1 constants and variables ***
'Const Q7_1_POS_CAL = 10                     'Unique positive multiplier for Q7.1.
'Const Q7_1_NEG_CAL = 10                     'Unique negative multiplier for Q7.1.
'Const NMBR_WND_SAMPLES = 3000/FAST_RATE 'Number of points to compute a three second mean horizontal wind.
'Public nr(2)
'Dim hor_wind
'Dim hor_wind_raw
'Alias nr(1) = Rn
'Alias nr(2) = Rn_meas
'Units Rn = W/m^2
'Units Rn_meas = W/^2
''*** End of Q7.1 constants and variables ***
'#EndIf


#If ( SENSOR_NR_LITE = TRUE ) Then
Const NRLITE_CAL = 1000/13.3                 'Unique multiplier for NR Lite (1000/sensitivity).
Const NMBR_WND_SAMPLES = 3000/FAST_RATE      '#pts to compute 3sec mean horizontal wind
Public nr(2)
Public hor_wind
Public hor_wind_raw
Alias nr(1) = Rn
Alias nr(2) = Rn_meas
Units Rn = W/m^2
Units Rn_meas = W/m^2
#EndIf


'#If ( SENSOR_CNR_2 = TRUE ) Then
''*** Beginning of CNR 2 constants and variables ***
'Const NR_SW_CAL = 1000/22              'Unique multiplier for CNR 2 net shortwave radiation (1000/sensitivity).
'Const NR_LW_CAL = 1000/12              'Unique multiplier for CNR 2 net longwave radiation (1000/sensitivity).
'Public nr(3)
'Alias nr(1) = Rn
'Alias nr(2) = Rn_sw
'Alias nr(3) = Rn_lw
'Units nr = W/m^2
''*** End of CNR 2 constants and variables ***
'#EndIf


'#If ( SENSOR_NR_01_CNR_1 = TRUE ) Then
''*** Beginning of NR 01/CNR 1 constants and variables ***
'Const NR_SW_DOWNWELL_CAL = 1000/15     'Unique multiplier for NR 01/CNR 1 shortwave downwelling radiation (1000/sensitivity).
'Const NR_SW_UPWELL_CAL = 1000/15       'Unique multiplier for NR 01/CNR 1 shortware upwelling radiation (1000/sensitivity).
'Const NR_LW_DOWNWELL_CAL = 1000/8      'Unique multiplier for NR 01/CNR 1 longwave downwelling radiation (1000/sensitivity).
'Const NR_LW_UPWELL_CAL = 1000/8        'Unique multiplier for NR 01/CNR 1 longwave upwelling radiation (1000/sensitivity).
'Public nr(9)                           'CNR 1 net radiometer.
'Alias nr(1) = Rn
'Alias nr(2) = albedo
'Alias nr(3) = Rs_downwell
'Alias nr(4) = Rs_upwell
'Alias nr(5) = Rl_downwell
'Alias nr(6) = Rl_upwell
'Alias nr(7) = T_nr
'Alias nr(8) = Rl_downwell_meas
'Alias nr(9) = Rl_upwell_meas
'Units nr = W/m^2
'Units albedo = arb
'Units T_nr = K
''*** End of NR 01/CNR 1 constants and variables ***
'#EndIf


'#If ( SENSOR_CNR_4 = TRUE ) Then
''*** Beginning of CNR 4 constants and variables ***
'Const NR_SW_DOWNWELL_CAL = 1000/15     'Unique multiplier for CNR 4 shortwave downwelling radiation (1000/sensitivity).
'Const NR_SW_UPWELL_CAL = 1000/15       'Unique multiplier for CNR 4 shortware upwelling radiation (1000/sensitivity).
'Const NR_LW_DOWNWELL_CAL = 1000/8      'Unique multiplier for CNR 4 longwave downwelling radiation (1000/sensitivity).
'Const NR_LW_UPWELL_CAL = 1000/8        'Unique multiplier for CNR 4 longwave upwelling radiation (1000/sensitivity).
''YSI 44031 Steinhart-Hart coefficients fit through -40 degrees C (239800 ohms), 20 degrees C (12260 ohms), and 80 degrees C (1458 ohms).
'Const A_SHH = 1.026613e-3              'Steinhart-Hart A coefficient.
'Const B_SHH = 2.395424e-4              'Steinhart-Hart B coefficient.
'Const C_SHH = 1.552561e-7              'Steinhart-Hart C coefficient.
'Public nr(9)                           'CNR 4 net radiometer.
'Dim X_cnr4
'Dim ln_R
'Alias nr(1) = Rn
'Alias nr(2) = albedo
'Alias nr(3) = Rs_downwell
'Alias nr(4) = Rs_upwell
'Alias nr(5) = Rl_downwell
'Alias nr(6) = Rl_upwell
'Alias nr(7) = T_nr
'Alias nr(8) = Rl_down_meas
'Alias nr(9) = Rl_up_meas
'Units nr = W/m^2
'Units albedo = arb
'Units T_nr = K
''*** End of CNR 4 constants and variables ***
'#EndIf


'#If ( SENSOR_TCAV = TRUE ) Then
''*** Beginning of TCAV constants and variables ***
'Const NMBR_TCAV = 2                    'Unique number of TCAV to measure.
'Public Tsoil(NMBR_TCAV)                'TCAV soil thermocouples.
'Public del_Tsoil(NMBR_TCAV)            'Change in soil temperature.
'Dim prev_Tsoil(NMBR_TCAV)
'Dim Tsoil_mean(NMBR_TCAV)
'Units Tsoil_mean = C
'Units del_Tsoil = C
'
'DataTable (soil_stat,TRUE,1)
'  TableHide
'  DataInterval (0,STAT_INT1,Min,1)
'
'  Average (NMBR_TCAV,Tsoil(1),IEEE4,slowsequence_disable_f)
'EndTable
''*** End of TCAV constants and variables ***
'#EndIf


'#If ( SENSOR_CS616 = TRUE ) Then
''*** Beginning of CS616 constants and variables ***
'Const NMBR_CS616 = 2                   'Unique number of CS616 to measure.
'Public cs616_wcr(NMBR_CS616)           'Water content reflectometer period.
'Public soil_water_T(NMBR_CS616)        'Volumetric soil water content with temperature correction.
'Dim cs616_T(NMBR_CS616)                'Water content reflectometer period with temperature correction.
'Units cs616_wcr = uSeconds
'Units soil_water_T = frac_v_wtr
''*** End of CS616 constants and variables ***
'#EndIf


'#If ( SENSOR_HFT3 = TRUE ) Then
''*** Beginning of HFT3 constants and variables ***
'Const NMBR_SHF = 4                     'Unique number of HFT3 to measure.
'Data 42                                'Unique multiplier for HFT3 #1.
'Data 42                                'Unique multiplier for HFT3 #2.
'Data 42                                'Unique multiplier for HFT3 #3.
'Data 42                                'Unique multiplier for HFT3 #4.
'Public shf(NMBR_SHF)                   'HFT soil heat flux plates.
'Dim shf_cal(NMBR_SHF)
'Units shf = W/m^2
''*** End of HFT3 constants and variables ***
'#EndIf


'#If ( SENSOR_HFP01 = TRUE ) Then
''*** Beginning of HFP01 constants and variables ***
'Const NMBR_SHF = 4                     'Unique number of HFP01 to measure.
'Data 1000/62                           'Unique multiplier for HFP01 #1 (1000/sensitivity).
'Data 1000/62                           'Unique multiplier for HFP01 #2 (1000/sensitivity).
'Data 1000/62                           'Unique multiplier for HFP01 #3 (1000/sensitivity).
'Data 1000/62                           'Unique multiplier for HFP01 #4 (1000/sensitivity).
'Public shf(NMBR_SHF)                   'HFP01 soil heat flux plates.
'Dim shf_cal(NMBR_SHF)
'Units shf = W/m^2
''*** End of HFP01 constants and variables ***
'#EndIf


'#If ( SENSOR_HFP01SC = TRUE ) Then
''*** Beginning of HFP01SC constants and variables ***
'Const NMBR_SHF = 2                     'Unique number of HFP01SC to measure.
'Data 1000/63.2                           'Unique multiplier for HFP01SC #1 (1000/sensitivity).
'Data 1000/62.3                           'Unique multiplier for HFP01SC #2 (1000/sensitivity).
'Data 1000/62                           'Unique multiplier for HFP01SC #3 (1000/sensitivity).
'Data 1000/62                           'Unique multiplier for HFP01SC #4 (1000/sensitivity).
'Const CAL_INTERVAL = 1440              'HFP01SC insitu calibration interval (minutes).
'Const END_CAL = STAT_INT1-1      'End HFP01SC insitu calibration one minute before the next output.
'Public shf(NMBR_SHF)                   'HFP01SC soil heat flux plates.
'Dim shf_cal(NMBR_SHF)
'Dim shf_mV(NMBR_SHF)
'Dim shf_mV_run(NMBR_SHF)
'Dim shf_mV_0(NMBR_SHF)
'Dim shf_mV_180(NMBR_SHF)
'Dim shf_mV_end(NMBR_SHF)
'Dim V_Rf(NMBR_SHF)
'Dim V_Rf_run(NMBR_SHF)
'Dim V_Rf_180(NMBR_SHF)
'Dim shf_cal_on_f
'Dim sw12_1_state                       'State of the switched 12Vdc port 1.
'Units shf = W/m^2
'Units shf_cal = W/(m^2 mV)
''*** End of HFP01SC constants and variables ***
'#EndIf

'*** Beginning of LI190SB constants and variables ***
Const PAR_CAL = 6.26				                          'Unique calibration value, uA/mmol/s/m^2
Const PAR_MULT_FLXDENS = 1000/(PAR_CAL*0.604)	        'multiplier for Flux Density_1 calculation
Const PAR_MULT_TOTFLX = (1/(PAR_CAL*0.604))*(FAST_RATE/1000)	'multiplier for Total Fluxes_1 calculation
Public PAR(3)
Alias PAR(1) = PAR_mV
Alias PAR(2) = PAR_flxdens
Alias PAR(3) = PAR_totflx
Units PAR_mV = mV
Units PAR_flxdens = umol/s/m^2
Units PAR_totflx = mmol/m^2

'*** Beginning of 034B constants and variables ***
Public WS_ms
Public WindDir
Units WS_ms = m/s
Units WindDir = degrees

Public Met1_workaround(5)
Alias Met1_workaround(1) = Met1_wnd_spd
Alias Met1_workaround(2) = Met1_rslt_wnd_spd
Alias Met1_workaround(3) = Met1_wnd_dir
Alias Met1_workaround(4) = Met1_std_wnd_dir
Units Met1_wnd_spd = m/s
Units Met1_rslt_wnd_spd = m/s
Units Met1_wnd_dir = degrees
Units Met1_std_wnd_dir = degrees

DataTable (work_met1_1,TRUE,1)
'  TableHide
  DataInterval (0,STAT_INT1,Min,0)
  WindVector (1,WS_ms,WindDir,IEEE4,(WS_ms=NAN OR WindDir=NAN),0,0,2)
EndTable

DataTable (work_met1_2,TRUE,1)
'  TableHide
  DataInterval (0,STAT_INT2,Min,0)
  WindVector (1,WS_ms,WindDir,IEEE4,(WS_ms=NAN OR WindDir=NAN),0,0,2)
EndTable


'*** Beginning of TE525 constants and variables ***
Public Rain_mm
Units Rain_mm=mm


'*** Beginning of GPS16X-HVS constants and variables ***
'Program the GPS16X-HVS to use 38.4 kbaud, no parity, 8 data bits, and 1 stop bit
Const LOCAL_TIME_OFFSET = -8                'Unique local time offset relative to UTC time
Public nmea_sentence(2) As String * 90
Public gps_data(15)
Alias gps_data(1) = latitude_a              'Degrees latitude (+ = East; - = West)
Alias gps_data(2) = latitude_b              'Minutes latitude
Alias gps_data(3) = longitude_a             'Degress longitude (+ = East; - = West)
Alias gps_data(4) = longitude_b             'Minutes longitude
Alias gps_data(5) = speed                   'Speed
Alias gps_data(6) = course                  'Course over ground
Alias gps_data(7) = magnetic_variation      'Magnetic variation from true north (+ = East; - = West)
Alias gps_data(8) = fix_quality             'GPS fix quality: 0 = invalid, 1 = GPS, 2 = 'differential GPS, 6 = estimated
Alias gps_data(9) = nmbr_satellites         'Number of satellites used for fix
Alias gps_data(10) = altitude               'Antenna altitude
Alias gps_data(11) = pps                    'Elapsed ms since last pulse per second (PPS) from GPS
Alias gps_data(12) = dt_since_gprmc         'Time since last GPRMC string, normally less than '1 second
Alias gps_data(13) = gps_ready              'Counts from 0 to 10, 10 = ready
Alias gps_data(14) = max_clock_change       'Maximum value the clock was changed
Alias gps_data(15) = nmbr_clock_change      'Number of times the clock was changed
Units latitude_a = degrees
Units latitude_b = minutes
Units longitude_a = degrees
Units longitude_b = minutes
Units speed = m/s
Units course = degrees
Units magnetic_variation = unitless
Units fix_quality = unitless
Units nmbr_satellites = unitless
Units altitude = m
Units pps = ms
Units dt_since_gprmc = s
Units gps_ready = unitless
Units max_clock_change = ms
Units nmbr_clock_change = samples

'#If ( SENSOR_N2O = TRUE ) Then
'Public n2o
'Public c_monoxide
'Units n2o=ppm
'Units c_monoxide=ppm
'#EndIf

'#If ( SENSOR_CH4 = TRUE ) Then
'Public ch4
'Public co2_picarro
'Units ch4=ppm
'Units co2_picarro=ppm
'#EndIf



'== OUTPUT DATA TABLES == 

'5min statistics
DataTable (CFNT_stats5,TRUE,-1)'FLUX_SIZE_CPU)
  DataInterval (0,STAT_INT1,Min,10)
  CardOut (0,-1)

  #If ( SENSOR_EC150 = true ) Then
  Sample(1,L,FP2)                       'monin obukhov length, meters
  Sample(1,u_star,FP2)                  'friction velocity, m/s  
  Sample(1,tau,FP2)                     'momemtum flux, kg/(m s^2)
  Sample(1,Fc_wpl,IEEE4)                'density-corrected (WPL) CO2 flux, mg/m3
  Sample(1,LE_wpl,FP2)                  'density-corrected (WPL) latent heat flux, W/m2
  Sample(1,Hc,FP2)                      'density-corrected sensible heat flux, W/m2

  Sample(1,Ts_Avg,FP2)                  'mean sonic temperature, degC
  Sample(1,Ts_stdev,FP2)                'stdev of sonic temp, degC
    FieldNames("Ts_Std")
  Sample(1,Tc_mean,FP2)                 'mean of corrected sonic temp, degC
    FieldNames("Tc_Avg")
  Sample(1,Uz_stdev,FP2)                'stdev of vertical wind, m/s
    FieldNames("Uz_Std")
  Sample(1,wnd_spd,FP2)                 'mean scalar wind speed, m/s
  Sample(1,rslt_wnd_spd,FP2)            'vector mean wind speed, m/s
  Sample(1,std_wnd_dir,FP2)             'scalar stdev of wind direction, degrees
  Sample(1,wnd_dir_compass,FP2)         'mean wind direction rel2 north, degrees
'  Totalize(1,n,UINT2,sonic_disable_f)   'total of good sonic values
'    FieldNames ("sonic_samples_Tot")
  Sample (1,sonic_uptime,FP2)

  Sample(1,CO2_ppm_Avg,FP2)
  Sample(1,CO2_mean,FP2)                'mean of CO2 conc, mg/m3
    FieldNames ("CO2_mg_m3_Avg")
  Sample(1,CO2_stdev,FP2)               'stdev of CO2 conc, mg/m3
    FieldNames ("CO2_mg_m3_Std")
  Sample(1,CO2_signal_Avg,FP2)
  Sample(1,H2O_g_kg_Avg,FP2)
  Sample(1,H2O_mean,FP2)                'mean of H2O conc, g/m3
    FieldNames ("H2O_g_m3_Avg")
  Sample(1,H2O_stdev,FP2)               'stdev of H2O conc, g/m3
    FieldNames ("H2O_g_m3_Std")
  Sample(1,H2O_signal_Avg,FP2)
  Sample(1,amb_tmpr_Avg,FP2)
  Sample(1,amb_press_mean,IEEE4)        'mean of ambient pressure, kPa
    FieldNames ("amb_press_Avg")
'  Totalize(1,n,UINT2,irga_disable_f)   'total of good sonic values
'    FieldNames ("irga_samples_Tot")
  Sample (1,irga_uptime,FP2)
  #EndIf

  #If ( SENSOR_HMP = TRUE ) Then
  Sample(1,T_hmp_mean,FP2)              'mean HMP temp, degC
    FieldNames ("T_hmp_Avg")
  Sample(1,RH_hmp_mean,FP2)             'mean HMP relative humidity, %
    FieldNames ("RH_hmp_Avg")
  Sample(1,e_hmp_mean,FP2)
    FieldNames ("e_hmp_Avg")
  Sample(1,e_sat_hmp_mean,FP2)
    FieldNames ("e_sat_hmp_Avg")
  #EndIf

  #If ( SENSOR_NR_LITE = TRUE ) Then
  Average (2,Rn,FP2,slowsequence_disable_f)
  #EndIf

'  #If ( SENSOR_CS616 = TRUE ) Then
'  Average (NMBR_CS616,soil_water_T(1),IEEE4,slowsequence_disable_f)
'  Average (NMBR_CS616,cs616_wcr(1),IEEE4,slowsequence_disable_f)
'  #EndIf

'  #If ( SENSOR_HFT3 = TRUE ) Then
'  Average (NMBR_SHF,shf(1),IEEE4,slowsequence_disable_f)
'  #EndIf

'  #If ( SENSOR_HFP01 = TRUE ) Then
'  Average (NMBR_SHF,shf(1),IEEE4,slowsequence_disable_f)
'  #EndIf

'  #If ( SENSOR_HFP01SC = TRUE ) Then
'  Average (NMBR_SHF,shf(1),IEEE4,shf_cal_on_f OR slowsequence_disable_f)
'  Sample (NMBR_SHF,shf_cal(1),IEEE4)
'  #EndIf

  #If ( SENSOR_190SB = TRUE ) Then
  Totalize (1,PAR_totflx,FP2, (PAR_totflx=NAN) )
  Average (1,PAR_flxdens,FP2, (PAR_flxdens=NAN) )
  #EndIf

  #If ( SENSOR_034B = TRUE ) Then
  Sample(1,Met1_wnd_spd,FP2)
  Sample(1,Met1_rslt_wnd_spd,FP2)
  Sample(1,Met1_wnd_dir,FP2)
  Sample(1,Met1_std_wnd_dir,FP2)
  #EndIf
  
  #If ( SENSOR_TE525 = TRUE ) Then
  Totalize(1,Rain_mm,FP2, (Rain_mm=NAN) )
  #EndIf

  Average (1,panel_tmpr,FP2,(panel_tmpr=NAN))
  Average (1,batt_volt,FP2,(slowsequence_disable_f OR batt_volt=NAN))
EndTable


'30min statistics
DataTable (CFNT_stats30,TRUE,-1)
  DataInterval (0,STAT_INT2,Min,10)
  CardOut (0,-1)

  #If ( SENSOR_EC150 = true ) Then
  Sample(1,L,FP2)                       'monin obukhov length, meters
  Sample(1,u_star,FP2)                  'friction velocity, m/s  
  Sample(1,tau,FP2)                     'momemtum flux, kg/(m s^2)
  Sample(1,Fc_wpl,IEEE4)                'density-corrected (WPL) CO2 flux, mg/m3
  Sample(1,LE_wpl,FP2)                  'density-corrected (WPL) latent heat flux, W/m2
  Sample(1,Hc,FP2)                      'density-corrected sensible heat flux, W/m2

  Sample(1,Ts_Avg,FP2)                  'mean sonic temperature, degC
  Sample(1,Ts_stdev,FP2)                'stdev of sonic temp, degC
    FieldNames("Ts_Std")
  Sample(1,Tc_mean,FP2)                 'mean of corrected sonic temp, degC
    FieldNames("Tc_Avg")
  Sample(1,Uz_stdev,FP2)                'stdev of vertical wind, m/s
    FieldNames("Uz_Std")
  Sample(1,wnd_spd,FP2)                 'mean scalar wind speed, m/s
  Sample(1,rslt_wnd_spd,FP2)            'vector mean wind speed, m/s
  Sample(1,std_wnd_dir,FP2)             'scalar stdev of wind direction, degrees
  Sample(1,wnd_dir_compass,FP2)         'mean wind direction rel2 north, degrees
'  Totalize(1,n,UINT2,sonic_disable_f)   'total of good sonic values
'    FieldNames ("sonic_samples_Tot")
  Sample (1,sonic_uptime,FP2)

  Sample(1,CO2_ppm_Avg,FP2)
  Sample(1,CO2_mean,FP2)                'mean of CO2 conc, mg/m3
    FieldNames ("CO2_mg_m3_Avg")
  Sample(1,CO2_stdev,FP2)               'stdev of CO2 conc, mg/m3
    FieldNames ("CO2_mg_m3_Std")
  Sample(1,CO2_signal_Avg,FP2)
  Sample(1,H2O_g_kg_Avg,FP2)
  Sample(1,H2O_mean,FP2)                'mean of H2O conc, g/m3
    FieldNames ("H2O_g_m3_Avg")
  Sample(1,H2O_stdev,FP2)               'stdev of H2O conc, g/m3
    FieldNames ("H2O_g_m3_Std")
  Sample(1,H2O_signal_Avg,FP2)
  Sample(1,amb_tmpr_Avg,FP2)
  Sample(1,amb_press_mean,IEEE4)        'mean of ambient pressure, kPa
    FieldNames ("amb_press_Avg")
'  Totalize(1,n,UINT2,irga_disable_f)   'total of good sonic values
'    FieldNames ("irga_samples_Tot")
  Sample (1,irga_uptime,FP2)
  #EndIf

  #If ( SENSOR_HMP = TRUE ) Then
  Sample(1,T_hmp_mean,FP2)              'mean HMP temp, degC
    FieldNames ("T_hmp_Avg")
  Sample(1,RH_hmp_mean,FP2)             'mean HMP relative humidity, %
    FieldNames ("RH_hmp_Avg")
  Sample(1,e_hmp_mean,FP2)
    FieldNames ("e_hmp_Avg")
  Sample(1,e_sat_hmp_mean,FP2)
    FieldNames ("e_sat_hmp_Avg")
  #EndIf

  #If ( SENSOR_NR_LITE = TRUE ) Then
  Average (2,Rn,FP2,slowsequence_disable_f)
  #EndIf

'  #If ( SENSOR_CS616 = TRUE ) Then
'  Average (NMBR_CS616,soil_water_T(1),IEEE4,slowsequence_disable_f)
'  Average (NMBR_CS616,cs616_wcr(1),IEEE4,slowsequence_disable_f)
'  #EndIf

'  #If ( SENSOR_HFT3 = TRUE ) Then
'  Average (NMBR_SHF,shf(1),IEEE4,slowsequence_disable_f)
'  #EndIf

'  #If ( SENSOR_HFP01 = TRUE ) Then
'  Average (NMBR_SHF,shf(1),IEEE4,slowsequence_disable_f)
'  #EndIf

'  #If ( SENSOR_HFP01SC = TRUE ) Then
'  Average (NMBR_SHF,shf(1),IEEE4,shf_cal_on_f OR slowsequence_disable_f)
'  Sample (NMBR_SHF,shf_cal(1),IEEE4)
'  #EndIf

  #If ( SENSOR_190SB = TRUE ) Then
  Totalize (1,PAR_totflx,FP2, (PAR_totflx=NAN) )
  Average (1,PAR_flxdens,FP2, (PAR_flxdens=NAN) )
  #EndIf

  #If ( SENSOR_034B = TRUE ) Then
  Sample(1,Met1_wnd_spd,FP2)
  Sample(1,Met1_rslt_wnd_spd,FP2)
  Sample(1,Met1_wnd_dir,FP2)
  Sample(1,Met1_std_wnd_dir,FP2)
  #EndIf
  
  #If ( SENSOR_TE525 = TRUE ) Then
  Totalize(1,Rain_mm,FP2, (Rain_mm=NAN) )
  #EndIf

  Average (1,panel_tmpr,FP2,(panel_tmpr=NAN))
  Average (1,batt_volt,FP2,(slowsequence_disable_f OR batt_volt=NAN))
EndTable


'Daily GPS values
DataTable (CFNT_site_daily,TRUE,-1)
  DataInterval (0,1,Day,10)
  CardOut(0,-1)
  Sample(1,sonic_azimuth,FP2)
  Average(1,latitude_a,FP2,(slowsequence_disable_f OR latitude_a=NAN))
  Average(1,latitude_b,FP2,(slowsequence_disable_f OR latitude_b=NAN))
  Average(1,longitude_a,FP2,(slowsequence_disable_f OR longitude_a=NAN))
  Average(1,longitude_b,FP2,(slowsequence_disable_f OR longitude_b=NAN))
  Average(1,magnetic_variation,FP2,(slowsequence_disable_f OR magnetic_variation=NAN))
  Average(1,nmbr_satellites,FP2,(slowsequence_disable_f OR nmbr_satellites=NAN))
  Average(1,altitude,IEEE4,(slowsequence_disable_f OR altitude=NAN))
  Minimum(1,gps_ready,FP2,(slowsequence_disable_f OR gps_ready=NAN),0)
  Sample(1,max_clock_change,UINT2)
  Sample(1,nmbr_clock_change,UINT2)
EndTable


'Time series data.
DataTable (CFNT_tsdata,TRUE,-1)
  DataInterval (0,FAST_RATE,mSec,100)
  CardOut (0,-1)

 #If ( SENSOR_EC150 = TRUE ) Then
  Sample (4,sonic_irga_raw(1),IEEE4)
    FieldNames ("Ux,Uy,Uz,Ts")
    Units Ux = m/s
    Units Uy = m/s
    Units Uz = m/s
    Units Ts = C
  Sample (1,sonic_irga_raw(5),FP2)
    FieldNames ("diag_sonic")
    Units diag_sonic = bitmap
  
'  Sample(1, sonic_irga_raw(6)/44 ,IEEE4)
'    FieldNames("co2_molar_density")
'    Units co2_molar_density=umol/m^3
'  Sample(1, sonic_irga_raw(7)/.018 ,IEEE4)
'    FieldNames("h2o_molar_density")
'    Units h2o_molar_density=mmol/m^3
 
  Sample (5,sonic_irga_raw(6),IEEE4)
    FieldNames ("CO2,H2O,diag_irga,amb_tmpr,amb_press")
    Units CO2 = mg/m^3
    Units H2O = g/m^3
    Units diag_irga = bitmap
    Units amb_tmpr = C
    Units amb_press = kPa
  Sample (2,sonic_irga_raw(11),FP2)
    FieldNames ("CO2_signal,H2O_signal")
    Units CO2_sig_strgth = unity
    Units H2O_sig_strgth = unity
  #EndIf


'  #If ( SENSOR_N2O = TRUE ) Then
'  Sample(1,n2o,FP2)
'  Sample(1,c_monoxide,FP2)
'  #EndIf
'  
'  #If ( SENSOR_CH4 = TRUE ) Then
'  Sample(1,ch4,FP2)
'  Sample(1,co2_picarro,FP2)
'  #EndIf
EndTable



'*** Program ***

BeginProg
'    #If ( (SENSOR_HFT3 = TRUE) OR (SENSOR_HFP01 = TRUE) OR (SENSOR_HFP01SC = TRUE) ) Then
'  'Load NMBR_SHF plate calibration.
'  For i = 1 To NMBR_SHF
'    Read shf_cal(i)
'  Next i
'  #EndIf

  sys_conf_var_file = FileOpen ("CPU:sys_conf_var.dat","rb",0) 'Check if a file exists.
  FileClose (sys_conf_var_file)

  If ( sys_conf_var_file = 0 ) Then
    Calfile (sonic_azimuth,1,"CPU:sys_conf_var.dat",0) 'Store the default values to the file.
  EndIf
  Calfile (sonic_azimuth,1,"CPU:sys_conf_var.dat",1) 'Read the values from the file.
  sonic_azimuth_prev = sonic_azimuth

  'Set the SDM clock speed.
  SDMSpeed (SDM_PER)
  Scan (FAST_RATE,mSec,SCAN_BUFFER_SIZE,0)
    'Datalogger panel temperature.
    PanelTemp (panel_tmpr,250)

'   'Begin n2o/co measurements
'   #If(SENSOR_N2O=true)Then
'   VoltDiff(n2o,1,mv5000,6,true,0,250,.0001,0)
'   VoltDiff(c_monoxide,1,mv5000,7,true,0,250,.0001,0)
'   #EndIf

   
'  'Begin ch2/co2 measurements
'   #If(SENSOR_CH4=true)Then
'   VoltDiff(ch4,1,mv5000,8,true,0,250,1,0)
'   VoltDiff(co2_picarro,1,mv5000,9,true,0,250,1,0)
'   #EndIf

    
    '*** Begining of 034B measurements ***
    PulseCount(WS_ms,1,1,2,1,0.799,0.2811)
    If (WS_ms <= 0.2811) Then (WS_ms = NAN)
    BrHalf(WindDir,1,mV5000,WIND_034B_SE_INPUT,1,1,5000,True,0,_60Hz,720,0)
    If ((WindDir >= 360) OR (WindDir < 0)) Then (WindDir = NAN)


    '*** Begining of TE525 measurements ***
    PulseCount(Rain_mm,1,2,2,0,0.254,0)


    #If ( SENSOR_EC150 = TRUE ) Then
      EC100 (sonic_irga_raw(1),EC100_SDM_ADDR,1)
      If ( sonic_irga_raw(8) = NAN ) Then 'The EC150 diagnostic word (diag_irga) is sonic_irga_raw(8).
        NAN_cnt = NAN_cnt+1
        configure_ec100_f = FALSE
      Else
        If ( NAN_cnt > 4 ) Then ( configure_ec100_f = TRUE )
        NAN_cnt = 0
      EndIf
  
      If ( configure_ec100_f ) Then
        Call Config (config_array(1,1),3,configure_ec100_f)
      ElseIf ( set_press_source_f ) Then
        Call Config (press_source_array(1,1),1,set_press_source_f)
      ElseIf ( do_zero_f ) Then
        Call Config (zero_array(1,1),1,do_zero_f)
      ElseIf ( do_CO2_span_f ) Then
        span_CO2_array(1,2) = CO2_span_gas
        Call Config (span_CO2_array(1,1),2,do_CO2_span_f)
      ElseIf ( do_H2O_span_f )
        span_H2O_array(1,2) = Td_span_gas
        Call Config (span_H2O_array(1,1),2,do_H2O_span_f)
      EndIf
  
      CallTable work_delay_csat
      CallTable work_delay_irga
    #EndIf
    
    CallTable CFNT_tsdata

'    #If ( SENSOR_CS616 = TRUE ) Then
'    '*** Beginning of CS616 measurements ***
'    CS616 (cs616_wcr(1),NMBR_CS616,CS616_ANALOG_INPUT,4,2,1,0)
'    '*** End of CS616 measurements ***
'    #EndIf

    #If ( (SENSOR_Q7_1 = TRUE) OR (SENSOR_NR_LITE = TRUE) ) Then
    hor_wind_raw = SQR (sonic_irga_raw(1)*sonic_irga_raw(1)+sonic_irga_raw(2)*sonic_irga_raw(2))
    AvgRun (hor_wind,1,hor_wind_raw,NMBR_WND_SAMPLES) 'Maintain a three second running mean of horizontal wind.
    #EndIf

    If ( scan_count >= OFFSET ) Then
      
      #If ( SENSOR_EC150 = true ) Then
      
      'CSAT processing
      GetRecord (dly_data_out(1),work_delay_csat,EC150_REC_BCK)
      Move (Ux,5,dly_data_out(1),5) 'Ux, Uy, Uz, Ts, diag_sonic
      If ( (diag_sonic <> NAN) AND (diag_sonic <> -1) ) Then 
'        diag_irga_tmp = diag_sonic    'there's no need for temp diag variables
'      Else
'        diag_irga_tmp = &h3f
'      EndIf
        sonic_disable_f = diag_sonic AND &h3f  '= 0011 1111
        If ( NOT sonic_disable_f ) Then
          Ts_absolute = Ts + 273.15
        EndIf
      Else 
        sonic_disable_f = TRUE
        Ts_absolute = NAN
      EndIf
'      mask = &h1         'since flags are no longer totaled, streamlined all this into above
'      For i = 1 To 6
'        diag_bits_sonic(i) = diag_sonic_tmp AND mask
'        mask = mask*2
'      Next i
'      sonic_disable_f = diag_sonic_tmp AND &h3f    'hexadecimal 3F = 0011 1111
'      If ( sonic_disable_f ) Then
'        Ts_absolute = NAN
'      Else
'        Ts_absolute = Ts + 273.15
'      EndIf

      'IRGA processing
      GetRecord (dly_data_out(1),work_delay_irga,EC150_REC_BCK)
      Move (CO2,7,dly_data_out(1),7) '+H2O,diag_irga,amb_tmpr,amb_press,CO2_sig_strgth,H2O_sig_strgth
      If ( (diag_irga <> NAN) AND (diag_irga <> -1) ) Then 
      '  diag_irga_tmp = diag_irga       'same as csat, no need for temp diagnostic bits
      'Else
      '  diag_irga_tmp = &h1fffff '= 0001 1111   1111 1111   1111 1111
      'EndIf
        irga_disable_f = sonic_disable_f OR (diag_irga AND &h1)
        If ( NOT irga_disable_f ) Then
          Td_tmp = LOG (H2O*R*(amb_tmpr+273.15)/(11.0178*(1.00072+3.2e-5*amb_press+5.9e-9*amb_press*amb_tmpr*amb_tmpr))) 
          'Td_tmp = ln (H2O*R*(T+273.15)/(Mv*0.61121*f)); Mv = 18 g/mol, f = 1.00072+3.2e-5*P+5.9e-9*P*T*T
          Td = (240.97*Td_tmp)/(17.502-Td_tmp) 'Buck (1981) Eq. (2a, 3a, & 6) and Leuning (2004) Eq. (6.23)
          'Compute fast response air temperature from sonic temperature and EC150 vapor density.
          Tc = Ts_absolute/(1+0.32*H2O*R*Ts_absolute/(amb_press*18)) - 273.15'Kaimal and Gaynor (1991) Eq. (3).
          divisor = (amb_press/(R*(Tc+273.15)))-(H2O/18) 'mixing ratio (X/dry air)
          Xc=CO2/(0.044*divisor)
          Xv=H2O/(0.018*divisor)
        EndIf
      Else
        irga_disable_f = TRUE
        Td = NAN
        Tc = NAN
        Xc = NAN
        Xv = NAN
      EndIf
'      mask = &h1
'      For i = 1 To 21
'        diag_bits_irga(i) = diag_irga_tmp AND mask
'        mask = mask*2
'      Next i
'      irga_disable_f = sonic_disable_f OR irga_bad_data_f
'      If( irga_disable_f ) Then
'        Td = NAN
'        Tc = NAN
'        Xc = NAN
'        Xv = NAN
'      Else
'        Td_tmp = LOG (H2O*R*(amb_tmpr+273.15)/(11.0178*(1.00072+3.2e-5*amb_press+5.9e-9*amb_press*amb_tmpr*amb_tmpr))) 
'        'Td_tmp = ln (H2O*R*(T+273.15)/(Mv*0.61121*f)); Mv = 18 g/mol, f = 1.00072+3.2e-5*P+5.9e-9*P*T*T
'        Td = (240.97*Td_tmp)/(17.502-Td_tmp) 'Buck (1981) Eq. (2a, 3a, & 6) and Leuning (2004) Eq. (6.23)
'        'Compute fast response air temperature from sonic temperature and EC150 vapor density.
'        Tc = Ts_absolute/(1+0.32*H2O*R*Ts_absolute/(amb_press*18)) - 273.15'Kaimal and Gaynor (1991) Eq. (3).
'        divisor = (amb_press/(R*(Tc+273.15)))-(H2O/18) 'mixing ratio (X/dry air)
'        Xc=CO2/(0.044*divisor)
'        Xv=H2O/(0.018*divisor)
'      EndIf
      
      '================== BEGIN 5 MIN STATS PROCESSING =========================

      'sonic cov for stats 1
      cov_array_sonic(1,1) = Ts
      Move (cov_array_sonic(1,2),3,Ux,3)
      CallTable work_cov1_csat
      If ( work_cov1_csat.Output(1,1) ) Then
        GetRecord (Ts_stdev,work_cov1_csat,1)
        sonic_uptime = sonic_samples/sonic_possible
        If ( sonic_uptime < min_uptime )
          Move(Hs,18,NAN,1) 'set Hs thru Ts_Avg to NAN
          'leave alone uptime values
          wnd_dir_compass = NAN
          u_star = NAN
        Else
          'Rotate the CSAT3A sonic head RHC system so the negative x-axis points north.
          wnd_dir_compass = (360+sonic_azimuth-wnd_dir_sonic) MOD 360
          'Make the CSAT3A sonic head wind direction fall between 0 to 180 degrees and 0 to -180 degrees.
          If ( wnd_dir_sonic > 180 ) Then ( wnd_dir_sonic = wnd_dir_sonic-360 )
          tau = SQR ((Ux_Uz_cov*Ux_Uz_cov)+(Uy_Uz_cov*Uy_Uz_cov))
          u_star = SQR (tau)
          Ts_stdev = SQR (Ts_stdev)
          Ux_stdev = SQR (Ux_stdev)
          Uy_stdev = SQR (Uy_stdev)
          Uz_stdev = SQR (Uz_stdev)
        EndIf
      EndIf

      'irga cov for stats 1
      cov_array_cs(1,1) = CO2
      Move (cov_array_cs(1,2),3,Ux,3)
      cov_array_cs(2,1) = H2O
      Move (cov_array_cs(2,2),3,Ux,3)
      cov_array_cs(3,1) = Tc
      Move (cov_array_cs(3,2),3,Ux,3)
      CallTable work_cov1_irga
      If ( work_cov1_irga.Output(1,1) ) Then
        GetRecord (CO2_stdev,work_cov1_irga,1)
        irga_uptime = irga_samples/irga_possible
        If ( irga_uptime < min_uptime )
          Move(Fc_wpl,22,NAN,1) ' set Fc_wpl thru Tc_mean to NAN
          'leave alone signal & uptime values
          Move(rho_a_mean,7,NAN,1) '+Fc_irga, LE_irga + co2/h2o WPL terms to NAN
          L = NAN
          rho_d_mean = NAN
          sigma_wpl = NAN
        Else
          L=-u_star^3*(Tc_mean+273.15)/(0.4*9.8*Ts_Uz_cov)   'obukohov length
          rho_d_mean = (amb_press_mean/((Tc_mean+273.15)*RD))-(H2O_mean*MU_WPL)
          rho_a_mean = (rho_d_mean+H2O_mean)/1000
          Fc_irga = CO2_Uz_cov                                'online fluxes
          LE_irga = LV*H2O_Uz_cov
          CO2_stdev = SQR (CO2_stdev)                        'stdevs
          H2O_stdev = SQR (H2O_stdev)
          Tc_stdev = SQR (Tc_stdev)
          sigma_wpl = H2O_mean/rho_d_mean                   'WPL term
  
          'EC150 Webb et al. (1980) term for carbon dioxide Eq. (24).
          CO2_wpl_LE = MU_WPL*CO2_mean/rho_d_mean*H2O_Uz_cov
          CO2_wpl_H = (1+(MU_WPL*sigma_wpl))*CO2_mean/(Tc_mean+273.15)*Tc_Uz_cov
          Fc_wpl = Fc_irga+CO2_wpl_LE+CO2_wpl_H
  
          'EC150 Webb et al. (1980) term for water vapor Eq. (25).
          H2O_wpl_LE = MU_WPL*sigma_wpl*LE_irga
          H2O_wpl_H = (1+(MU_WPL*sigma_wpl))*H2O_mean/(Tc_mean+273.15)*LV*Tc_Uz_cov
          LE_wpl = LE_irga+H2O_wpl_LE+H2O_wpl_H
        EndIf
      EndIf
      #EndIf


      #If ( (SENSOR_HMP = TRUE) ) Then
        #If ( SENSOR_EC150 = FALSE ) Then
          Dim amb_press_mean = SITE_PRESS
        #EndIf
        CallTable work_stats1_hmp
        If ( work_stats1_hmp.Output(1,1) ) Then
          GetRecord(T_hmp_mean,work_stats1_hmp,1)
          H2O_hmp_mean = e_hmp_mean/((T_hmp_mean+273.15)*RV)
          rho_d_mean_hmp = (amb_press_mean-e_hmp_mean)/((T_hmp_mean+273.15)*RD)
          rho_a_mean_hmp = (rho_d_mean_hmp+H2O_hmp_mean)/1000
          RH_hmp_mean = 100*e_hmp_mean/e_sat_hmp_mean
        EndIf
      #EndIf


      If ( work_cov1_csat.Output(1,1) ) Then
        #If ( (SENSOR_EC150 = FALSE) AND (SENSOR_HMP = TRUE) ) Then
        Hs = rho_a_mean_hmp*CP*Ts_Uz_cov
        tau = rho_a_mean_hmp*tau
        #EndIf
        
        #If ( SENSOR_EC150 = TRUE ) Then
        Hs = rho_a_mean*CP*Ts_Uz_cov
        tau = rho_a_mean*tau
        Hc = rho_a_mean*CP*Tc_Uz_cov
        #EndIf
      EndIf


'      #If ( SENSOR_TCAV = TRUE ) Then
'      '*** Beginning of soil temperature processing ***
'      CallTable soil_stat
'      If ( soil_stat.Output(1,1) ) Then
'        GetRecord (Tsoil_mean(1),soil_stat,1)
'
'        'Compute the change in soil temperature.
'        For i = 1 To NMBR_TCAV
'          del_Tsoil(i) = Tsoil_mean(i)-prev_Tsoil(i)
'          prev_Tsoil(i) = Tsoil_mean(i)
'        Next i
'      EndIf
'      '*** End of soil temperature processing ***
'      #EndIf

      CallTable work_met1_1
      If ( work_met1_1.Output(1,1) ) Then
        GetRecord(Met1_workaround(1),work_met1_1,1)
        'correct for azimuth?!
      EndIf

      '==================================
      CallTable CFNT_stats5       '====== save 5 minute statistics
      '==================================
      
      '===================== BEGIN 30 MIN STATS PROCESSING ===================
      
      #If ( SENSOR_EC150 = true ) Then
      
      'sonic cov for stats 2 - 30min
      CallTable work_cov2_csat
      If ( work_cov2_csat.Output(1,1) ) Then
        GetRecord (Ts_stdev,work_cov2_csat,1)
        sonic_uptime = sonic_samples/sonic_possible
        If ( sonic_uptime < min_uptime ) 
          Move(Hs,18,NAN,1) 'set Hs thru Ts_Avg to NAN
          'leave alone uptime values
          wnd_dir_compass = NAN
          u_star = NAN
        Else
          'Rotate the CSAT3A sonic head RHC system so the negative x-axis points north.
          wnd_dir_compass = (360+sonic_azimuth-wnd_dir_sonic) MOD 360
          'Make the CSAT3A sonic head wind direction fall between 0 to 180 degrees and 0 to -180 degrees.
          If ( wnd_dir_sonic > 180 ) Then ( wnd_dir_sonic = wnd_dir_sonic-360 )
          tau = SQR ((Ux_Uz_cov*Ux_Uz_cov)+(Uy_Uz_cov*Uy_Uz_cov))
          u_star = SQR (tau)
          Ts_stdev = SQR (Ts_stdev)
          Ux_stdev = SQR (Ux_stdev)
          Uy_stdev = SQR (Uy_stdev)
          Uz_stdev = SQR (Uz_stdev)
        EndIf
      EndIf

      'irga cov for stats 2
      CallTable work_cov2_irga
      If ( work_cov2_irga.Output(1,1) ) Then
        GetRecord (CO2_stdev,work_cov2_irga,1)
        If ( irga_uptime < min_uptime )
          Move(Fc_wpl,22,NAN,1) ' set Fc_wpl thru Tc_mean to NAN
          'leave alone signal & uptime values
          Move(rho_a_mean,7,NAN,1) '+Fc_irga, LE_irga + co2/h2o WPL terms to NAN          L = NAN
          L = NAN
          rho_d_mean = NAN
          sigma_wpl = NAN
        Else
          L=-u_star^3*(Tc_mean+273.15)/(0.4*9.8*Ts_Uz_cov)   'obukohov length
          rho_d_mean = (amb_press_mean/((Tc_mean+273.15)*RD))-(H2O_mean*MU_WPL)
          rho_a_mean = (rho_d_mean+H2O_mean)/1000
          Fc_irga = CO2_Uz_cov                                'online fluxes
          LE_irga = LV*H2O_Uz_cov
          CO2_stdev = SQR (CO2_stdev)                        'stdevs
          H2O_stdev = SQR (H2O_stdev)
          Tc_stdev = SQR (Tc_stdev)
          sigma_wpl = H2O_mean/rho_d_mean                   'WPL term
  
          'EC150 Webb et al. (1980) term for carbon dioxide Eq. (24).
          CO2_wpl_LE = MU_WPL*CO2_mean/rho_d_mean*H2O_Uz_cov
          CO2_wpl_H = (1+(MU_WPL*sigma_wpl))*CO2_mean/(Tc_mean+273.15)*Tc_Uz_cov
          Fc_wpl = Fc_irga+CO2_wpl_LE+CO2_wpl_H
  
          'EC150 Webb et al. (1980) term for water vapor Eq. (25).
          H2O_wpl_LE = MU_WPL*sigma_wpl*LE_irga
          H2O_wpl_H = (1+(MU_WPL*sigma_wpl))*H2O_mean/(Tc_mean+273.15)*LV*Tc_Uz_cov
          LE_wpl = LE_irga+H2O_wpl_LE+H2O_wpl_H
        EndIf
      EndIf
      #EndIf


      #If ( (SENSOR_HMP = TRUE) ) Then
        #If ( SENSOR_EC150 = FALSE ) Then
          Dim amb_press_mean = SITE_PRESS
        #EndIf
        CallTable work_stats2_hmp
        If ( work_stats2_hmp.Output(1,1) ) Then
          GetRecord(T_hmp_mean,work_stats2_hmp,1)
          H2O_hmp_mean = e_hmp_mean/((T_hmp_mean+273.15)*RV)
          rho_d_mean_hmp = (amb_press_mean-e_hmp_mean)/((T_hmp_mean+273.15)*RD)
          rho_a_mean_hmp = (rho_d_mean_hmp+H2O_hmp_mean)/1000
          RH_hmp_mean = 100*e_hmp_mean/e_sat_hmp_mean
        EndIf
      #EndIf


      If ( work_cov2_csat.Output(1,1) ) Then
        #If ( (SENSOR_EC150 = FALSE) AND (SENSOR_HMP = TRUE) ) Then
        Hs = rho_a_mean_hmp*CP*Ts_Uz_cov
        tau = rho_a_mean_hmp*tau
        #EndIf
        
        #If ( SENSOR_EC150 = TRUE ) Then
        Hs = rho_a_mean*CP*Ts_Uz_cov
        tau = rho_a_mean*tau
        Hc = rho_a_mean*CP*Tc_Uz_cov
        #EndIf
      EndIf      
            
      CallTable work_met1_2
      If ( work_met1_2.Output(1,1) ) Then
        GetRecord(Met1_workaround(1),work_met1_2,1)
        'correct for azimuth?!
      EndIf
      
      '==============================
      CallTable CFNT_stats30   '===== save 30min stats
      '==============================
      
      slowsequence_disable_f = TRUE
      If ( slowsequence_finished_f ) Then
        slowsequence_finished_f = FALSE
        slowsequence_disable_f = FALSE
      EndIf
    Else
      scan_count = scan_count+1
    EndIf
  NextScan


  '===========================================================================
  '====================== SLOW SCAN INTERVAL =================================
  SlowSequence

  Scan (1,Sec,3,0)
    Battery (batt_volt)

    #If ( SENSOR_HMP = TRUE ) Then
    VoltDiff (T_hmp,1,mV1000,HMP_ANALOG_T_INPUT,TRUE,0,A_INTEG,HMP_T_MULT,HMP_T_OFFSET)
    VoltDiff (RH_hmp,1,mV1000,HMP_ANALOG_RH_INPUT,TRUE,0,A_INTEG,HMP_RH_MULT,HMP_RH_OFFSET)
    VaporPressure (e_hmp,T_hmp,RH_hmp)
    SatVP (e_sat_hmp,T_hmp)
    #EndIf


'    #If ( SENSOR_Q7_1 = TRUE ) Then
'    VoltDiff (Rn_meas,1,AutoRange,NR_ANALOG_INPUT,TRUE,0,A_INTEG,1,0)
'    If ( sonic_irga_raw(5) = 0 ) Then 'sonic_irga_raw(5) is the instantaneous CSAT3(A) diagnostic word.
'      If (Rn_meas > 0) Then
'        Rn_meas = Rn_meas*Q7_1_POS_CAL
'        Rn = Rn_meas*(1+(0.0132*hor_wind)/(0.066+(0.2*hor_wind)))
'      Else
'        Rn_meas = Rn_meas*Q7_1_NEG_CAL
'        Rn = Rn_meas*((0.00174*hor_wind)+0.99755)
'      EndIf
'    Else
'      If (Rn_meas > 0) Then
'        Rn_meas = Rn_meas*Q7_1_POS_CAL
'        Rn = Rn_meas*1.045
'      Else
'        Rn_meas = Rn_meas*Q7_1_NEG_CAL
'        Rn = Rn_meas
'      EndIf
'    EndIf
'    #EndIf


    #If ( SENSOR_NR_LITE = TRUE ) Then
    VoltDiff (Rn_meas,1,mV20,NR_ANALOG_INPUT,TRUE,0,A_INTEG,NRLITE_CAL,0)
    If ( sonic_irga_raw(5) = 0 ) Then    'sonic_irga_raw(5) = inst. CSAT3 diag word
      Rn = Rn_meas*(1+(0.021286*(hor_wind-5)))
    Else
      Rn = Rn_meas
    EndIf
    #EndIf


'    #If ( SENSOR_CNR_2 = TRUE ) Then
'    VoltDiff (Rn_sw,2,AutoRange,NR_ANALOG_INPUT,TRUE,0,A_INTEG,1,0)
'    Rn_sw = Rn_sw*NR_SW_CAL
'    Rn_lw = Rn_lw*NR_LW_CAL
'    #EndIf


'    #If ( SENSOR_NR_01_CNR_1 = TRUE ) Then
'    VoltDiff (Rs_downwell,4,AutoRange,NR_ANALOG_INPUT,TRUE,0,A_INTEG,1,0)
'    Rs_downwell = Rs_downwell*NR_SW_DOWNWELL_CAL
'    Rs_upwell = Rs_upwell*NR_SW_UPWELL_CAL
'    Rl_downwell = Rl_downwell*NR_LW_DOWNWELL_CAL
'    Rl_upwell = Rl_upwell*NR_LW_UPWELL_CAL
'    Resistance (T_nr,1,mV200,T_NR_ANALOG_INPUT,Ix1,1,1675,TRUE,TRUE,0,A_INTEG,1,0)
'    T_nr = T_nr/100
'    PRT (T_nr,1,T_nr,1,273.15)
'    'Compute net radiation, albedo, downwelling and upwelling longwave radiation.
'    Rn = Rs_downwell-Rs_upwell+Rl_downwell_meas-Rl_upwell_meas
'    albedo = Rs_upwell/Rs_downwell
'    Rl_downwell = Rl_downwell_meas+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
'    Rl_upwell = Rl_upwell_meas+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
'    #EndIf


'    #If ( SENSOR_CNR_4 = TRUE ) Then
'    VoltDiff (Rs_downwell,4,AutoRange,NR_ANALOG_INPUT,TRUE,0,A_INTEG,1,0)
'    Rs_downwell = Rs_downwell*NR_SW_DOWNWELL_CAL
'    Rs_upwell = Rs_upwell*NR_SW_UPWELL_CAL
'    Rl_downwell = Rl_downwell*NR_LW_DOWNWELL_CAL
'    Rl_upwell = Rl_upwell*NR_LW_UPWELL_CAL
'    BrHalf (X_cnr4,1,AutoRange,T_NR_ANALOG_INPUT,Vx1,1,5000,TRUE,0,A_INTEG,1,0)
'    ln_R = LOG (1000*X_cnr4/(1-X_cnr4))
'    T_nr = (1/(A_SHH+B_SHH*ln_R+C_SHH*ln_R*ln_R*ln_R))+273.15
'    'Compute net radiation, albedo, downwelling and upwelling longwave radiation.
'    Rn = Rs_downwell-Rs_upwell+Rl_down_meas-Rl_up_meas
'    albedo = Rs_upwell/Rs_downwell
'    Rl_downwell = Rl_down_meas+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
'    Rl_upwell = Rl_up_meas+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
'    #EndIf


'    #If ( SENSOR_TCAV = TRUE ) Then
'    TCDiff (Tsoil(1),NMBR_TCAV,AutoRange,TCAV_ANALOG_INPUT,TypeE,panel_tmpr,TRUE,0,A_INTEG,1,0)
'    #EndIf


'    #If ( SENSOR_CS616 = TRUE ) Then
'    'Apply temperature correction to CS616 period and find volumetric water content.
'    For ii = 1 To NMBR_TCAV 'NMBR_TCAV must equal NMBR_CS616
'      If ( (10 <= Tsoil(ii)) AND (Tsoil(ii) <= 40) ) Then
'        cs616_T(ii) = cs616_wcr(ii)+(20-Tsoil(ii))*(0.526+cs616_wcr(ii)*(-0.052+cs616_wcr(ii)*0.00136))
'      Else
'        cs616_T(ii) = cs616_wcr(ii)
'      EndIf
'      soil_water_T(ii) = -0.0663+cs616_T(ii)*(-0.0063+cs616_T(ii)*0.0007)
'    Next ii
'    #EndIf


'    #If ( SENSOR_HFT3 = TRUE ) Then
'    VoltDiff (shf(1),NMBR_SHF,AutoRange,SHF_ANALOG_INPUT,TRUE,0,A_INTEG,shf_cal(),0)
'    #EndIf


'    #If ( SENSOR_HFP01 = TRUE ) Then
'    VoltDiff (shf(1),NMBR_SHF,AutoRange,SHF_ANALOG_INPUT,TRUE,0,A_INTEG,shf_cal(),0)
'    #EndIf


'    #If ( SENSOR_HFP01SC = TRUE ) Then
'    VoltDiff (shf_mV(1),NMBR_SHF,AutoRange,SHF_ANALOG_INPUT,TRUE,0,A_INTEG,1,0)
'    'Apply HFP01SC soil heat flux plate calibration.
'    For ii = 1 To NMBR_SHF
'      shf(ii) = shf_mV(ii)*shf_cal(ii)
'    Next ii
'    'Power the HFP01SC heaters.
'    PortSet (9,sw12_1_state)
'    'Measure voltage across the heater (V_Rf).
'    VoltSe (V_Rf(1),NMBR_SHF,mV5000,SHF_HEATER_ANALOG_INPUT,TRUE,0,A_INTEG,1,0)
'    'Maintain filtered values for calibration.
'    AvgRun (shf_mV_run(1),NMBR_SHF,shf_mV(1),10)
'    AvgRun (V_Rf_run(1),NMBR_SHF,V_Rf(1),10)
'    'Begin HFP01SC calibration one minute into very CAL_INTERVAL minutes.
'    If ( IfTime (1,CAL_INTERVAL,Min) ) Then
'      shf_cal_on_f = TRUE
'      Move (shf_mV_0(1),NMBR_SHF,shf_mV_run(1),NMBR_SHF)
'      sw12_1_state = TRUE
'    EndIf
'    If ( IfTime (4,CAL_INTERVAL,Min) ) Then
'      Move (shf_mV_180(1),NMBR_SHF,shf_mV_run(1),NMBR_SHF)
'      Move (V_Rf_180(1),NMBR_SHF,V_Rf_run(1),NMBR_SHF)
'      sw12_1_state = FALSE
'    EndIf
'    'End HFP01SC calibration sequence.
'    If ( IfTime (END_CAL,CAL_INTERVAL,Min) ) Then
'      Move (shf_mV_end(1),NMBR_SHF,shf_mV_run(1),NMBR_SHF)
'      'Compute new HFP01SC calibration factors.
'      For ii = 1 To NMBR_SHF
'        shf_cal(ii) = V_Rf_180(ii)*V_Rf_180(ii)*128.7/ABS (((shf_mV_0(ii)+shf_mV_end(ii))/2)-shf_mV_180(ii))
'      Next ii
'      shf_cal_on_f = FALSE
'    EndIf
'    #EndIf

    '== LI190SB 
    VoltDiff (PAR_mV,1,mV20,PAR_ANALOG_INPUT,True,200,250,1.0,0)
    PAR_flxdens = PAR_mV*PAR_MULT_FLXDENS
    PAR_totflx = PAR_mV*PAR_MULT_TOTFLX

    '== Garmin GPS
    GPS (latitude_a,Com4,LOCAL_TIME_OFFSET*3600,0,nmea_sentence(1))

    If ( sonic_azimuth_prev <> sonic_azimuth ) Then
      sonic_azimuth_prev = sonic_azimuth
      Calfile (sonic_azimuth,1,"CPU:sys_conf_var.dat",0)  'Store the new value to the file.
    EndIf

    CallTable CFNT_site_daily
    slowsequence_finished_f = TRUE
  NextScan
EndProg
