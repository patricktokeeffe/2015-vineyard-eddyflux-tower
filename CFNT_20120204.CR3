''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' REgional Approaches to Climate CHange 
' Laboratory for Atmospheric Research
' Washington State University
'
' Site: Cook Farm No-Till
' Description: This program combines fast measurements of CO2 and H2O with 3D wind speeds to 
'   generate near real-time surface fluxes of CO2, latent & sensible heat. Metereological 
'   statistics are continuously generated in five and thirty minute intervals. 
' 
'Version history
' 20120204  
'   copied 30min flux table as a 5min flux table, removed extraneous variables, ensured each
'   variable has units, no correctness checks; start file naming scheme; enclosed sensor
'   statements in compilation condtionals where necessary to match original style; relocated 
'   ANAL0G_INTEGRATION constant from sensor input mapping to program variable setup; 
'   [pto, patrick.okeeffe@email.wsu.edu]
' ....
' backfill?
' ...
' 20110216  version 3.0
'   Copyright (c) 2002, 2006, 2010 Campbell Scientific, Inc. All rights reserved.
'
'
'TODO 
' - remove unused sensors
' - remove extraneous variables from 30min flux table
' - possibly create a lean 10hz table for download
' -
'
' Flux sign convention is positive upwards, away from the surface and negative downwards, 
' towards the surface. Before computing online fluxes, the datalogger will introduce lags 
' into the eddy covariance data to account for the fixed instrument delays. The lags are
' dependent on the instrument setting and/or the scan interval. Search for "Fixed inherent 
' lag" and set the delay to the appropriate value. The raw data is not lagged. The site 
' attendant must load in several constants and calibration values. Search for the text string 
' "unique" to find the locations where unique constants and calibration values are entered.
'   
'C        Celsius
'degrees  degrees (angle)
'g        grams
'J        Joules
'kg       kilograms
'kPa      kilopascals
'm        meters
'mg       milligrams
'mmol     millimoles
'mol      moles
's        seconds
'umol     micromols
'V        volts
'W        Watts


'== REACCH SENSOR CONFIGURATION ==
Const SENSOR_EC150       = TRUE  'EC150/CSAT3A    OP-IRGA & 3d sonic anemometer/thermometer
Const SENSOR_HMP         = TRUE  'HMP155A/HMP45C  temperature and relative humidity
Const SENSOR_NR_LITE     = TRUE  'NR Lite         net radiometer
Const SENSOR_190SB       = TRUE  'LI190SB         licor quantum sensor??
Const SENSOR_034B        = TRUE  '034B            cup & vane
Const SENSOR_TE525       = TRUE  'TE525           texas instruments rain gage


'== OPTIONAL DEPLOYMENT SENSORS 
Const SENSOR_N2O         = FALSE  'Los Gatos N2O/CO analyzer
Const SENSOR_CH4         = FALSE  'Picarro CO2/CH4/H2O analyzer
Const SENSOR_5TM         = FALSE  '5TM             decagon soil temp/moisture probe
Const SENSOR_HFP01       = FALSE  'HFP01           soil heat flux plates


'== SENSORS NOT USED ==
Const SENSOR_Q7_1        = FALSE  'Q7.1            net radiometer
Const SENSOR_CNR_2       = FALSE  'CNR 2           net radiometer
Const SENSOR_NR_01_CNR_1 = FALSE  'NR 01/CNR 1     net radiometer
Const SENSOR_CNR_4       = FALSE  'CNR 4           net radiometer
Const SENSOR_TCAV        = FALSE  'TCAV            type E thermocouple averaging soil temperature probes
Const SENSOR_CS616       = FALSE  'CS616           water content reflectometers (volumetric soil moisture)
Const SENSOR_HFT3        = FALSE  'HFT3            soil heat flux plates
Const SENSOR_HFP01SC     = FALSE  'HFP01SC         soil heat flux plates



'== SENSOR INPUT MAP ==

#If ( SENSOR_EC150 = TRUE ) Then
  Const EC100_SDM_ADDR = 1               'Unique SDM address for EC100.
#EndIf


#If ( SENSOR_HMP = TRUE ) Then
  Const HMP_ANALOG_T_INPUT = 2             'Unique analog input channel.
  Const HMP_ANALOG_RH_INPUT = 3           'Unique: HMP RH input
#EndIf


#If ( SENSOR_Q7_1 = TRUE ) Then
  Const NR_ANALOG_INPUT = 4              'Unique analog input channel.
#EndIf


#If ( SENSOR_NR_LITE = TRUE ) Then
  Const NR_ANALOG_INPUT = 4              'Unique analog input channel.
#EndIf


#If ( SENSOR_CNR_2 = TRUE ) Then
  Const NR_ANALOG_INPUT = 4              'Unique analog input channel.
#EndIf


#If ( SENSOR_NR_01_CNR_1 = TRUE ) Then
  Const T_NR_ANALOG_INPUT = 1            'Unique analog input channel.
  Const NR_ANALOG_INPUT = 2              'Unique analog input channel.
#EndIf


#If ( SENSOR_CNR_4 = TRUE ) Then
  Const T_NR_ANALOG_INPUT = 1            'Unique analog input channel.
  Const NR_ANALOG_INPUT = 2              'Unique analog input channel.
#EndIf


#If ( SENSOR_CS616 = TRUE ) Then
  Const CS616_ANALOG_INPUT = 11          'Unique analog input channel.
#EndIf


#If ( SENSOR_TCAV = TRUE ) Then
  Const TCAV_ANALOG_INPUT = 7            'Unique analog input channel.
#EndIf


#If ( SENSOR_HFT3 = TRUE ) Then
  Const SHF_ANALOG_INPUT = 9            'Unique analog input channel.
#EndIf


#If ( SENSOR_HFP01 = TRUE ) Then
  Const SHF_ANALOG_INPUT = 9           'Unique analog input channel.
#EndIf


#If ( SENSOR_HFP01SC = TRUE ) Then
  Const SHF_ANALOG_INPUT = 9             'Unique analog input channel.
  Const SHF_HEATER_ANALOG_INPUT = 25     'Unique analog input channel.
#EndIf
 
#If ( SENSOR_5TM = TRUE ) Then
  Const 5tm_sdi_input = 1             'Unique sdi input channel.
#EndIf


Const PAR_ANALOG_INPUT = 5             'Unique: PAR diff input chan #

#If ( SENSOR_034B = TRUE ) Then
  Const WIND_034B_SE_INPUT = 11          'Unique: 034B single ended input = D6H
#EndIf

PipeLineMode

'*** General constants and variables ***
Const SCAN_INTERVAL = 100  'Unique value, measurement rate 100 ms (10 Hz), 40 ms (25 Hz), or 50 (20 Hz).
Const OUTPUT_INTERVAL = 30 'Unique value, online flux data output interval in minutes.
Const SDM_PER = 30         'Unique value, default SDM clock speed.
Const ANALOG_INTEGRATION = _60Hz  'Slowsequence analog measurement integration time, _60Hz or _50Hz.

Const OFFSET = 17                                        'An offset delay that will be introduced to the eddy covariance data used to compute online fluxes.
Const SCAN_BUFFER_SIZE = 60*INT (1000/SCAN_INTERVAL)     'Compute a 60 second scan buffer.
Const NUM_DAY_CPU = 7                                    'Number of days of data to store on the CPU.
Const FLUX_SIZE_CPU = (NUM_DAY_CPU*1440)/OUTPUT_INTERVAL 'Size of flux data table on CPU [days].

Const MU_WPL = 29/18                                     'Ratio of the molecular weight of dry air to that of water vapor.
Const R = .0083143                                      'Universal gas constant [kPa m^3/(K mol)].
Const RD = R/29                                          'Gas constant for dry air [kPa m^3/(K g)].
Const LV = 2440                                          'Estimate of the latent heat of vaporization [J/g].
Const RV = R/18                                          'Gas constant for water vapor [kPa m^3/(K g)].

Dim dly_data_out(7)                                      'Array used to temporarily store the lagged record.

'Other measurements.
Public panel_tmpr
Public batt_volt
Units panel_tmpr = C
Units batt_volt = V
Public co2_mix_ratio
Public co2_molar_density
Public h2o_mix_ratio
Public h2o_molar_density
Public L

'Program working variables.
Dim scan_count As Long                                   'Number scans executed.
Dim slowsequence_finished_f As Boolean                   'Flag used to indicate the SlowSequence has finished its scan.
Dim slowsequence_disable_f As Boolean = {TRUE}           'Flag used to decimate statistics in main scan.
Dim sys_conf_var_file As Long                            'Filehandle for the file that contains the system configuration variables in the CPU.
Dim i As Long                                            'Main scan index variable.
Dim ii As Long                                           'Slow sequence scan index variable.
Dim n = {1}
Units n = samples





#If ( SENSOR_EC150 = TRUE ) Then
'*** Beginning of EC100 configure, zero, and span constants and variables, and subroutine ***
Const BANDWIDTH = 20            '20 = 20 Hz
Const DIFFERENTIAL_PRESSURE = 0 '0 = disabled
Const TEMPERATURE_SOURCE = 0    '0 = ambient temperature sensor
Const BB = 0                    'BB = EC100 basic pressure transducer
Const EB = 2                    'EB = EC100 enhanced pressure transducer

Public CO2_span_gas
Public Td_span_gas

Dim config_array(3,2) = {0,BANDWIDTH,3,DIFFERENTIAL_PRESSURE,7,TEMPERATURE_SOURCE}
Dim press_source_array(1,2) = {2,0}   'Pressure source,basic pressure transducer (default).
Dim zero_array(1,2) = {11,1}          'Zero/Span command,set zero value.
Dim span_CO2_array(2,2) = {12,0,11,2} 'CO2 span concentration,0; Zero/Span command,set CO2 span value (default).
Dim span_H2O_array(2,2) = {13,0,11,3} 'H2O span dew point temperature,0; Zero/Span command,set H2O span value (default).

Public set_press_source_f As Boolean
Public do_zero_f As Boolean
Public do_CO2_span_f As Boolean
Public do_H2O_span_f As Boolean
Dim configure_ec100_f As Boolean = {TRUE}
Dim NAN_cnt As Long
Dim retry_config_f As Boolean


Sub Config (cmd_array(4,2),num_cmd As Long,retry_config_f As Boolean)
  Dim i As Long
  Dim config_result As Long
  Dim save_flash_f As Boolean = {FALSE}

  For i = 1 To num_cmd
    EC100Configure (config_result,1,cmd_array(i,1),cmd_array(i,2))
    If ( config_result = NAN ) Then ( ExitFor )
    If ( (cmd_array(i,1) = 2) OR (cmd_array(i,1) = 11) ) Then ( save_flash_f = TRUE )
  Next i

  If ( i = num_cmd+1 ) Then
    If ( save_flash_f ) Then ( EC100Configure (config_result,EC100_SDM_ADDR,99,2718) )
    If ( config_result <> NAN ) Then ( retry_config_f = FALSE )
  EndIf

  SetStatus ("SkippedScan",0)
EndSub
'*** End of EC100 configure, zero, and span constants and variables, and subroutine ***
#EndIf


#If ( SENSOR_EC150 = TRUE ) Then
'*** Beginning of CSAT3A sonic head constants, variables, and working data table ***
Const CP = 1004.67                         'Estimate of heat capacity of air [J/(kg K)].

Public sonic(5)
Alias sonic(1) = Ux
Alias sonic(2) = Uy
Alias sonic(3) = Uz
Alias sonic(4) = Ts
Alias sonic(5) = diag_sonic

Public diag_bits_sonic(6) As Boolean       'Sonic warning flags.
Public sonic_azimuth                       'Enter sonic azimuth using keyboard after program has compiled (azimuth of the CSAT3(A) negative x-axis see Section 3.2.1 CSAT3A Azimuth in the OPEC manual).
Public ati_azimuth
Alias diag_bits_sonic(1) = amp_l_f         'Amplitude low warning flag.
Alias diag_bits_sonic(2) = amp_h_f         'Amplitude high warning flag.
Alias diag_bits_sonic(3) = sig_lck_f       'Poor signal lock warning flag.
Alias diag_bits_sonic(4) = del_T_f         'Delta temperature warning flag.
Alias diag_bits_sonic(5) = aq_sig_f        'Sonic acquiring signals warning flag.
Alias diag_bits_sonic(6) = sonic_cal_err_f 'Signature error in reading CSAT3A sonic head calibration data.
Units diag_bits_sonic = arb
Units sonic_azimuth = degrees
Units ati_azimuth = degress
Dim sonic_irga_raw(12)                     'EC150 w/CSAT3A sonic head (not lagged).

Dim diag_sonic_tmp As Long                 'Temporary variable used to break out the CSAT3A sonic head diagnostic bits.
Dim sonic_disable_f As Boolean             'TRUE when CSAT3A sonic head diagnostic warning flags are on or CSAT3A sonic head has not sent data or an SDM signature error is reported.
Dim Ts_absolute                            'Sonic temperature (K).
Dim sonic_azimuth_prev

Dim cov_array_sonic(1,4)                   'Arrays used to hold the input data for the covariance instructions (CSAT3A sonic head).
Dim cov_out_sonic(18)                      'CSAT3A sonic head statistics.
Alias cov_out_sonic(1) = Hs                'Sensible heat flux using sonic temperature.
Alias cov_out_sonic(2) = tau               'Momentum flux.
Alias cov_out_sonic(3) = u_star            'Friction velocity.
Alias cov_out_sonic(4) = Ts_stdev
Alias cov_out_sonic(5) = Ts_Ux_cov
Alias cov_out_sonic(6) = Ts_Uy_cov
Alias cov_out_sonic(7) = Ts_Uz_cov
Alias cov_out_sonic(8) = Ux_stdev
Alias cov_out_sonic(9) = Ux_Uy_cov
Alias cov_out_sonic(10) = Ux_Uz_cov
Alias cov_out_sonic(11) = Uy_stdev
Alias cov_out_sonic(12) = Uy_Uz_cov
Alias cov_out_sonic(13) = Uz_stdev
Alias cov_out_sonic(14) = wnd_spd
Alias cov_out_sonic(15) = rslt_wnd_spd
Alias cov_out_sonic(16) = wnd_dir_sonic
Alias cov_out_sonic(17) = std_wnd_dir
Alias cov_out_sonic(18) = wnd_dir_compass
Units Hs = W/m^2
Units tau = kg/(m s^2)
Units u_star = m/s
Units Ts_stdev = C
Units Ts_Ux_cov = C m/s
Units Ts_Uy_cov = C m/s
Units Ts_Uz_cov = C m/s
Units Ux_stdev = m/s
Units Ux_Uy_cov = (m/s)^2
Units Ux_Uz_cov = (m/s)^2
Units Uy_stdev = m/s
Units Uy_Uz_cov = (m/s)^2
Units Uz_stdev = m/s
Units wnd_spd = m/s
Units rslt_wnd_spd = m/s
Units wnd_dir_sonic = degrees
Units std_wnd_dir = degrees
Units wnd_dir_compass = degrees

DataTable (delay_3d,TRUE,OFFSET)
  TableHide

  Sample (5,sonic_irga_raw(1),IEEE4)
EndTable

DataTable (comp_cov_3d,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  'Compute covariances from CSAT3A sonic head data.
  Covariance (4,cov_array_sonic(1,1),IEEE4,sonic_disable_f,10)
  WindVector (1,Uy,Ux,IEEE4,sonic_disable_f,0,1,2)
EndTable
'*** End of CSAT3A sonic head constants, variables, and working data table ***
#EndIf


'*** Beginning of EC150 constants, variables, and working data table ***
#If ( SENSOR_EC150 = TRUE ) Then
Const DELAY_EC150 = INT (4000/SCAN_INTERVAL/BANDWIDTH) 'Automatically computed lag of the EC150 data.
Const EC150_REC_BCK = OFFSET-DELAY_EC150 'Number of records back to align EC150 data.

Public irga(9)
Alias irga(1) = CO2
Alias irga(2) = H2O
Alias irga(3) = diag_irga
Alias irga(4) = amb_tmpr
Alias irga(5) = amb_press
Alias irga(6) = CO2_sig_strgth
Alias irga(7) = H2O_sig_strgth
Alias irga(8) = Tc
Alias irga(9) = Td

Public diag_bits_irga(21) As Boolean        'Gas analyzer warning flags.
Alias diag_bits_irga(1) = irga_bad_data_f   'EC150 bad data warning flag.
Alias diag_bits_irga(2) = gen_sys_fault_f   'General system fault warning flag.
Alias diag_bits_irga(3) = sys_startup_f     'EC150 starting up warning flag.
Alias diag_bits_irga(4) = motor_spd_f       'EC150 motor speed out of bounds warning flag.
Alias diag_bits_irga(5) = tec_tmpr_f        'Thermoelectric cooler temperature out of bounds warning flag.
Alias diag_bits_irga(6) = src_pwr_f         'EC150 source power out of bounds warning flag.
Alias diag_bits_irga(7) = src_tmpr_f        'EC150 source temperature out of bounds warning flag.
Alias diag_bits_irga(8) = src_curr_f        'EC150 source current out of bounds warning flag.
Alias diag_bits_irga(9) = irga_off_f        'Gas analyzer head is powered down.
Alias diag_bits_irga(10) = irga_sync_f      'EC150 not synchronized with home pulse warning flag.
Alias diag_bits_irga(11) = amb_tmpr_f       'Invalid ambient temperature warning flag.
Alias diag_bits_irga(12) = amb_press_f      'Invalid ambient pressure warning flag.
Alias diag_bits_irga(13) = CO2_I_f          'CO2 I out of bounds warning flag.
Alias diag_bits_irga(14) = CO2_Io_f         'CO2 Io out of bounds warning flag.
Alias diag_bits_irga(15) = H2O_I_f          'H2O I out of bounds warning flag.
Alias diag_bits_irga(16) = H2O_Io_f         'H2O Io out of bounds warning flag.
Alias diag_bits_irga(17) = CO2_Io_var_f     'CO2 Io moving variation out of bounds warning flag.
Alias diag_bits_irga(18) = H2O_Io_var_f     'H2O Io moving variation out of bounds warning flag.
Alias diag_bits_irga(19) = CO2_sig_strgth_f 'CO2 signal strength warning flag.
Alias diag_bits_irga(20) = H2O_sig_strgth_f 'H2O signal strength warning flag.
Alias diag_bits_irga(21) = irga_cal_err_f   'EC150 calibration data signature error.
Units diag_bits_irga = arb

Public Xc                                   'CO2 molar mixing ratio.
Public Xv                                   'H2O molar mixing ratio.
Dim divisor                                 'Temporary variable used to find molar mixing ratio.
Dim diag_irga_tmp As Long                   'Temporary variable used to break out the EC150 diagnostic bits.
Dim irga_disable_f As Boolean               'TRUE when EC150 sends bad data.
Dim rho_d_mean                              'Density of dry air used in Webb et al. term [kg / m^3].
Dim sigma_wpl                               'Webb et al. sigma = density of water vapor / density of dry air.
Dim mask As Long
Dim Td_tmp
Units Xc = umol/mol
Units Xv = mmol/mol

Dim cov_array_cs(3,4)                       'Arrays used to hold the input data for the covariance instructions (sonic and EC150).
Dim cov_out_cs(26)                          'EC150 statistics.
Alias cov_out_cs(1) = Fc_wpl                'Carbon dioxide flux (EC150), with Webb et al. term.
Alias cov_out_cs(2) = LE_wpl                'Latent heat flux (EC150), with Webb et al. term.
Alias cov_out_cs(3) = Hc                    'Sensible heat flux using sonic temperature corrected for water vapor measured by the EC150.
Alias cov_out_cs(4) = CO2_stdev
Alias cov_out_cs(5) = CO2_Ux_cov
Alias cov_out_cs(6) = CO2_Uy_cov
Alias cov_out_cs(7) = CO2_Uz_cov
Alias cov_out_cs(8) = H2O_stdev
Alias cov_out_cs(9) = H2O_Ux_cov
Alias cov_out_cs(10) = H2O_Uy_cov
Alias cov_out_cs(11) = H2O_Uz_cov
Alias cov_out_cs(12) = Tc_stdev
Alias cov_out_cs(13) = Tc_Ux_cov
Alias cov_out_cs(14) = Tc_Uy_cov
Alias cov_out_cs(15) = Tc_Uz_cov
Alias cov_out_cs(16) = CO2_mean
Alias cov_out_cs(17) = H2O_mean
Alias cov_out_cs(18) = amb_press_mean
Alias cov_out_cs(19) = Tc_mean              'Sonic temperature corrected for humidity.
Alias cov_out_cs(20) = rho_a_mean
Alias cov_out_cs(21) = Fc_irga              'Carbon dioxide flux (EC150), without Webb et al. term.
Alias cov_out_cs(22) = LE_irga              'Latent heat flux (EC150), without Webb et al. term.
Alias cov_out_cs(23) = CO2_wpl_LE           'Carbon dioxide flux (EC150), Webb et al. term due to latent heat flux.
Alias cov_out_cs(24) = CO2_wpl_H            'Carbon dioxide flux (EC150), Webb et al. term due to sensible heat flux.
Alias cov_out_cs(25) = H2O_wpl_LE           'Latent heat flux (EC150), Webb et al. term due to latent heat flux.
Alias cov_out_cs(26) = H2O_wpl_H            'Latent heat flux (EC150), Webb et al. term due to sensible heat flux.
Units Fc_wpl = mg/(m^2 s)
Units LE_wpl = W/m^2
Units Hc = W/m^2
Units CO2_stdev = mg/m^3
Units CO2_Ux_cov = mg/(m^2 s)
Units CO2_Uy_cov = mg/(m^2 s)
Units CO2_Uz_cov = mg/(m^2 s)
Units H2O_stdev = g/m^3
Units H2O_Ux_cov = g/(m^2 s)
Units H2O_Uy_cov = g/(m^2 s)
Units H2O_Uz_cov = g/(m^2 s)
Units Tc_stdev = C
Units Tc_Ux_cov = C m/s
Units Tc_Uy_cov = C m/s
Units Tc_Uz_cov = C m/s
Units CO2_mean = mg/m^3
Units H2O_mean = g/m^3
Units amb_press_mean = kPa
Units Tc_mean = C
Units rho_a_mean = kg/m^3
Units Fc_irga = mg/(m^2 s)
Units LE_irga = W/m^2
Units CO2_wpl_LE = mg/(m^2 s)
Units CO2_wpl_H = mg/(m^2 s)
Units H2O_wpl_LE = W/m^2
Units H2O_wpl_H = W/m^2

DataTable (delay_cs,TRUE,OFFSET)
  TableHide

  Sample (7,sonic_irga_raw(6),IEEE4)
EndTable

DataTable (comp_cov_cs,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  'Compute covariance of CO2 against sonic wind data.
  Covariance (4,cov_array_cs(1,1),IEEE4,irga_disable_f,4)
  'Compute covariance of H2O against sonic wind data.
  Covariance (4,cov_array_cs(2,1),IEEE4,irga_disable_f,4)
  'Compute covariance of Tc (computed fast response temperature) against sonic wind data.
  Covariance (4,cov_array_cs(3,1),IEEE4,irga_disable_f,4)
  Average (2,CO2,IEEE4,irga_disable_f)
  Average (1,amb_press,IEEE4,irga_disable_f)
  Average (1,Tc,IEEE4,irga_disable_f)
EndTable


DisplayMenu ("System Control",TRUE)
  MenuItem ("Sonic Azmth",sonic_azimuth)
  'MenuItem ("ati azmth",ati_azimuth)
  SubMenu ("Change Press Source")
    MenuItem ("Select Srce",press_source_array(1,2))
  MenuPick (BB,EB)
    MenuItem ("Set Source",set_press_source_f)
  MenuPick (True)
  EndSubMenu
  SubMenu ("On Site Zero & Span")
    SubMenu ("Span Concentrations")
      MenuItem ("CO2",CO2_span_gas)
      MenuItem ("Td",Td_span_gas)
    EndSubMenu
    MenuItem ("Do Zero",do_zero_f)
  MenuPick (True)
    MenuItem ("Do CO2 Span",do_CO2_span_f)
  MenuPick (True)
    MenuItem ("Do H2O Span",do_H2O_span_f)
  MenuPick (True)
    DisplayValue ("CO2 um/m dry",Xc)
    DisplayValue ("H2O mm/m dry",Xv)
    DisplayValue ("Td degrees C",Td)
  EndSubMenu
EndMenu
'*** End of EC150 constants, variables, and working data table ***
#EndIf







#If ( SENSOR_HMP = TRUE ) Then
'*** Beginning HMP constants, variables, and working data table. ***
Const HMP_T_MULT = 0.14               'Unique multiplier for temperature; HMP155A = 0.14 or HMP45C = 0.1.
Const HMP_T_OFFSET = -80              'Unique offset for temperature;  HMP155A = -80 or HMP45C = -40.

Public hmp(3)
Alias hmp(1) = T_hmp                  'HMP temperature.
Alias hmp(2) = RH_hmp                 'HMP relative humidity.
Alias hmp(3) = e_hmp                  'HMP vapor pressure.
Units T_hmp = C
Units RH_hmp = percent
Units e_hmp = kPa

Dim e_sat_hmp                         'HMP saturation vapor pressure.
Dim rho_d_mean_hmp                    'Density of dry air used in Webb et al. term [kg / m^3].

Dim cov_out_hmp(6)                    'HMP statistics.
Alias cov_out_hmp(1) = T_hmp_mean     'Mean HMP temperature.
Alias cov_out_hmp(2) = e_hmp_mean     'Mean HMP vapor pressure.
Alias cov_out_hmp(3) = e_sat_hmp_mean 'Mean HMP saturation vapor pressure.
Alias cov_out_hmp(4) = H2O_hmp_mean   'Mean HMP vapor density.
Alias cov_out_hmp(5) = RH_hmp_mean    'Mean HMP relative humidity.
Alias cov_out_hmp(6) = rho_a_mean_hmp 'Mean air density using HMP measurements.
Units T_hmp_mean = C
Units e_hmp_mean = kPa
Units e_sat_hmp_mean = kPa
Units H2O_hmp_mean = g/m^3
Units RH_hmp_mean = %
Units rho_a_mean_hmp = kg/m^3

DataTable (stats_hmp,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  Average (1,T_hmp,IEEE4,slowsequence_disable_f)
  Average (1,e_hmp,IEEE4,slowsequence_disable_f)
  Average (1,e_sat_hmp,IEEE4,slowsequence_disable_f)
EndTable
'*** End of HMP constants, variables, and working data table ***
#EndIf





#If (SENSOR_HMP = TRUE) Then
Const SITE_PRESS = 100
'*** End of user entered site density and pressure constants ***
#EndIf


#If ( SENSOR_Q7_1 = TRUE ) Then
'*** Beginning of Q7.1 constants and variables ***
Const Q7_1_POS_CAL = 10                     'Unique positive multiplier for Q7.1.
Const Q7_1_NEG_CAL = 10                     'Unique negative multiplier for Q7.1.
Const NMBR_WND_SAMPLES = 3000/SCAN_INTERVAL 'Number of points to compute a three second mean horizontal wind.
Public nr(2)
Dim hor_wind
Dim hor_wind_raw
Alias nr(1) = Rn
Alias nr(2) = Rn_meas
Units Rn = W/m^2
Units Rn_meas = W/^2
'*** End of Q7.1 constants and variables ***
#EndIf


#If ( SENSOR_NR_LITE = TRUE ) Then
'*** Beginning of NR Lite constants and variables ***
Const NRLITE_CAL = 1000/13.3                 'Unique multiplier for NR Lite (1000/sensitivity).
Const NMBR_WND_SAMPLES = 3000/SCAN_INTERVAL 'Number of points to compute a three second mean horizontal wind.
Public nr(2)
Dim hor_wind
Dim hor_wind_raw
Alias nr(1) = Rn
Alias nr(2) = Rn_meas
Units Rn = W/m^2
Units Rn_meas = W/m^2
'*** End of NR Lite constants and variables ***
#EndIf


#If ( SENSOR_CNR_2 = TRUE ) Then
'*** Beginning of CNR 2 constants and variables ***
Const NR_SW_CAL = 1000/22              'Unique multiplier for CNR 2 net shortwave radiation (1000/sensitivity).
Const NR_LW_CAL = 1000/12              'Unique multiplier for CNR 2 net longwave radiation (1000/sensitivity).
Public nr(3)
Alias nr(1) = Rn
Alias nr(2) = Rn_sw
Alias nr(3) = Rn_lw
Units nr = W/m^2
'*** End of CNR 2 constants and variables ***
#EndIf


#If ( SENSOR_NR_01_CNR_1 = TRUE ) Then
'*** Beginning of NR 01/CNR 1 constants and variables ***
Const NR_SW_DOWNWELL_CAL = 1000/15     'Unique multiplier for NR 01/CNR 1 shortwave downwelling radiation (1000/sensitivity).
Const NR_SW_UPWELL_CAL = 1000/15       'Unique multiplier for NR 01/CNR 1 shortware upwelling radiation (1000/sensitivity).
Const NR_LW_DOWNWELL_CAL = 1000/8      'Unique multiplier for NR 01/CNR 1 longwave downwelling radiation (1000/sensitivity).
Const NR_LW_UPWELL_CAL = 1000/8        'Unique multiplier for NR 01/CNR 1 longwave upwelling radiation (1000/sensitivity).
Public nr(9)                           'CNR 1 net radiometer.
Alias nr(1) = Rn
Alias nr(2) = albedo
Alias nr(3) = Rs_downwell
Alias nr(4) = Rs_upwell
Alias nr(5) = Rl_downwell
Alias nr(6) = Rl_upwell
Alias nr(7) = T_nr
Alias nr(8) = Rl_downwell_meas
Alias nr(9) = Rl_upwell_meas
Units nr = W/m^2
Units albedo = arb
Units T_nr = K
'*** End of NR 01/CNR 1 constants and variables ***
#EndIf


#If ( SENSOR_CNR_4 = TRUE ) Then
'*** Beginning of CNR 4 constants and variables ***
Const NR_SW_DOWNWELL_CAL = 1000/15     'Unique multiplier for CNR 4 shortwave downwelling radiation (1000/sensitivity).
Const NR_SW_UPWELL_CAL = 1000/15       'Unique multiplier for CNR 4 shortware upwelling radiation (1000/sensitivity).
Const NR_LW_DOWNWELL_CAL = 1000/8      'Unique multiplier for CNR 4 longwave downwelling radiation (1000/sensitivity).
Const NR_LW_UPWELL_CAL = 1000/8        'Unique multiplier for CNR 4 longwave upwelling radiation (1000/sensitivity).
'YSI 44031 Steinhart-Hart coefficients fit through -40 degrees C (239800 ohms), 20 degrees C (12260 ohms), and 80 degrees C (1458 ohms).
Const A_SHH = 1.026613e-3              'Steinhart-Hart A coefficient.
Const B_SHH = 2.395424e-4              'Steinhart-Hart B coefficient.
Const C_SHH = 1.552561e-7              'Steinhart-Hart C coefficient.
Public nr(9)                           'CNR 4 net radiometer.
Dim X_cnr4
Dim ln_R
Alias nr(1) = Rn
Alias nr(2) = albedo
Alias nr(3) = Rs_downwell
Alias nr(4) = Rs_upwell
Alias nr(5) = Rl_downwell
Alias nr(6) = Rl_upwell
Alias nr(7) = T_nr
Alias nr(8) = Rl_down_meas
Alias nr(9) = Rl_up_meas
Units nr = W/m^2
Units albedo = arb
Units T_nr = K
'*** End of CNR 4 constants and variables ***
#EndIf


#If ( SENSOR_TCAV = TRUE ) Then
'*** Beginning of TCAV constants and variables ***
Const NMBR_TCAV = 2                    'Unique number of TCAV to measure.
Public Tsoil(NMBR_TCAV)                'TCAV soil thermocouples.
Public del_Tsoil(NMBR_TCAV)            'Change in soil temperature.
Dim prev_Tsoil(NMBR_TCAV)
Dim Tsoil_mean(NMBR_TCAV)
Units Tsoil_mean = C
Units del_Tsoil = C

DataTable (soil_stat,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  Average (NMBR_TCAV,Tsoil(1),IEEE4,slowsequence_disable_f)
EndTable
'*** End of TCAV constants and variables ***
#EndIf


#If ( SENSOR_CS616 = TRUE ) Then
'*** Beginning of CS616 constants and variables ***
Const NMBR_CS616 = 2                   'Unique number of CS616 to measure.
Public cs616_wcr(NMBR_CS616)           'Water content reflectometer period.
Public soil_water_T(NMBR_CS616)        'Volumetric soil water content with temperature correction.
Dim cs616_T(NMBR_CS616)                'Water content reflectometer period with temperature correction.
Units cs616_wcr = uSeconds
Units soil_water_T = frac_v_wtr
'*** End of CS616 constants and variables ***
#EndIf


#If ( SENSOR_HFT3 = TRUE ) Then
'*** Beginning of HFT3 constants and variables ***
Const NMBR_SHF = 4                     'Unique number of HFT3 to measure.
Data 42                                'Unique multiplier for HFT3 #1.
Data 42                                'Unique multiplier for HFT3 #2.
Data 42                                'Unique multiplier for HFT3 #3.
Data 42                                'Unique multiplier for HFT3 #4.
Public shf(NMBR_SHF)                   'HFT soil heat flux plates.
Dim shf_cal(NMBR_SHF)
Units shf = W/m^2
'*** End of HFT3 constants and variables ***
#EndIf


#If ( SENSOR_HFP01 = TRUE ) Then
'*** Beginning of HFP01 constants and variables ***
Const NMBR_SHF = 4                     'Unique number of HFP01 to measure.
Data 1000/62                           'Unique multiplier for HFP01 #1 (1000/sensitivity).
Data 1000/62                           'Unique multiplier for HFP01 #2 (1000/sensitivity).
Data 1000/62                           'Unique multiplier for HFP01 #3 (1000/sensitivity).
Data 1000/62                           'Unique multiplier for HFP01 #4 (1000/sensitivity).
Public shf(NMBR_SHF)                   'HFP01 soil heat flux plates.
Dim shf_cal(NMBR_SHF)
Units shf = W/m^2
'*** End of HFP01 constants and variables ***
#EndIf


#If ( SENSOR_HFP01SC = TRUE ) Then
'*** Beginning of HFP01SC constants and variables ***
Const NMBR_SHF = 2                     'Unique number of HFP01SC to measure.
Data 1000/63.2                           'Unique multiplier for HFP01SC #1 (1000/sensitivity).
Data 1000/62.3                           'Unique multiplier for HFP01SC #2 (1000/sensitivity).
Data 1000/62                           'Unique multiplier for HFP01SC #3 (1000/sensitivity).
Data 1000/62                           'Unique multiplier for HFP01SC #4 (1000/sensitivity).
Const CAL_INTERVAL = 1440              'HFP01SC insitu calibration interval (minutes).
Const END_CAL = OUTPUT_INTERVAL-1      'End HFP01SC insitu calibration one minute before the next output.
Public shf(NMBR_SHF)                   'HFP01SC soil heat flux plates.
Dim shf_cal(NMBR_SHF)
Dim shf_mV(NMBR_SHF)
Dim shf_mV_run(NMBR_SHF)
Dim shf_mV_0(NMBR_SHF)
Dim shf_mV_180(NMBR_SHF)
Dim shf_mV_end(NMBR_SHF)
Dim V_Rf(NMBR_SHF)
Dim V_Rf_run(NMBR_SHF)
Dim V_Rf_180(NMBR_SHF)
Dim shf_cal_on_f
Dim sw12_1_state                       'State of the switched 12Vdc port 1.
Units shf = W/m^2
Units shf_cal = W/(m^2 mV)
'*** End of HFP01SC constants and variables ***
#EndIf

'*** Beginning of LI190SB constants and variables ***
Const PAR_CAL = 6.26				'Unique calibration vlaue for LI190SB in uA/mmol/s/m^2
Const PAR_MULT_FLXDENS = 1000/(PAR_CAL*0.604)	'multiplier for Flux Density_1 calculation
Const PAR_MULT_TOTFLX = (1/(PAR_CAL*0.604))*(SCAN_INTERVAL/1000)	'multiplier for Total Fluxes_1 calculation
Public PAR(3)
Alias PAR(1) = PAR_mV
Alias PAR(2) = PAR_flxdens
Alias PAR(3) = PAR_totflx
Units PAR_mV = mV
Units PAR_flxdens = umol/s/m^2
Units PAR_totflx = mmol/m^2
'*** End of LI190SB constants and variables ***

'*** Beginning of 034B constants and variables ***
Public WS_ms
Public WindDir
Units WS_ms=m/s
Units WindDir=degrees
'*** End of 034B constants and variables ***

'*** Beginning of TE525 constants and variables ***
Public Rain_mm
Units Rain_mm=mm
'*** End of TE525 constants and variables ***

'*** Beginning of GPS16X-HVS constants and variables ***
'Program the GPS16X-HVS to use 38.4 kbaud, no parity, 8 data bits, and 1 stop bit
Const LOCAL_TIME_OFFSET = -8 'Unique local time offset relative to UTC time
Dim nmea_sentence(2) As String * 90
Public gps_data(15)
Alias gps_data(1) = latitude_a 'Degrees latitude (+ = East; - = West)
Alias gps_data(2) = latitude_b 'Minutes latitude
Alias gps_data(3) = longitude_a 'Degress longitude (+ = East; - = West)
Alias gps_data(4) = longitude_b 'Minutes longitude
Alias gps_data(5) = speed 'Speed
Alias gps_data(6) = course 'Course over ground
Alias gps_data(7) = magnetic_variation 'Magnetic variation from true north (+ = East; - = West)
Alias gps_data(8) = fix_quality 'GPS fix quality: 0 = invalid, 1 = GPS, 2 = 'differential GPS, 6 = estimated
Alias gps_data(9) = nmbr_satellites 'Number of satellites used for fix
Alias gps_data(10) = altitude 'Antenna altitude
Alias gps_data(11) = pps 'Elapsed ms since last pulse per second (PPS) from GPS
Alias gps_data(12) = dt_since_gprmc 'Time since last GPRMC string, normally less than '1 second
Alias gps_data(13) = gps_ready 'Counts from 0 to 10, 10 = ready
Alias gps_data(14) = max_clock_change 'Maximum value the clock was changed
Alias gps_data(15) = nmbr_clock_change 'Number of times the clock was changed
Units latitude_a = degrees
Units latitude_b = minutes
Units longitude_a = degrees
Units longitude_b = minutes
Units speed = m/s
Units course = degrees
Units magnetic_variation = unitless
Units fix_quality = unitless
Units nmbr_satellites = unitless
Units altitude = m
Units pps = ms
Units dt_since_gprmc = s
Units gps_ready = unitless
Units max_clock_change = ms
Units nmbr_clock_change = samples
'*** End of GPS16X-HVS constants and variables ***

#If (sensor_n2o=true) Then
Public n2o
Public c_monoxide
Units n2o=ppm
Units c_monoxide=ppm
#EndIf

#If (sensor_ch4=true) Then
Public ch4
Public co2_picarro
Units ch4=ppm
Units co2_picarro=ppm
#EndIf



'*** Duplicated flux table - converted to 5 minutes and only containing met ***
DataTable (CFNT_met_5min,TRUE,FLUX_SIZE_CPU)
  DataInterval (0,5,Min,10)
  CardOut (0,-1)

  #If ( SENSOR_EC150 = true ) Then
    Sample(1,L,FP2)                       'monin obukhov length, meters
      Units L = m
    Sample(1,Hs,IEEE4)                    'sensible heat flux, W m-2
    Sample(1,u_star,FP2)                  'friction velocity, m/s
    Sample(1,Ts_stdev,FP2)                'stdev of sonic temp, degC
    Sample(1,Uz_stdev,FP2)                'stdev of vertical wind, m/s
    Sample(1,wnd_spd,FP2)                 'mean scalar wind speed, m/s
    Sample(1,rslt_wnd_spd,FP2)            'vector mean wind speed, m/s
    Sample(1,std_wnd_dir,FP2)             'scalar stdev of wind direction, degrees
    Sample(1,wnd_dir_compass,FP2)         'mean wind direction rel2 north, degrees
    Average(1,Ts,FP2,sonic_disable_f)     'mean sonic temperature, degC
    Totalize(1,n,UINT2,sonic_disable_f)   'total of good sonic values
      FieldNames ("sonic_samples_Tot")
    Sample(1,Fc_wpl,FP2)                  'density-corrected (WPL) CO2 flux, mg/m3
    Sample(1,LE_wpl,IEEE4)                'density-corrected (WPL) latent heat flux, W/m2
    Sample(1,Hc,IEEE4)                    'vapor density-corrected sensible heat flux, W/m2
    Sample(1,CO2_stdev,FP2)               'stdev of CO2 conc, mg/m3
    Sample(1,H2O_stdev,FP2)               'stdev of H2O conc, g/m3
    Sample(1,Tc_stdev,FP2)                'stdev of corrected sonic temp, degC
    Sample(1,CO2_mean,FP2)                'mean of CO2 conc, mg/m3
    Sample(1,H2O_mean,FP2)                'mean of H2O conc, g/m3
    Sample(1,amb_press_mean,IEEE4)        'mean of ambient pressure, kPa
    Sample(1,Tc_mean,FP2)                 'mean of corrected sonic temp, degC
    Average(1,CO2_sig_strgth,FP2,irga_disable_f) 
      FieldNames ("CO2_sig_strgth_mean")
    Average (1,H2O_sig_strgth,FP2,irga_disable_f)
      FieldNames ("H2O_sig_strgth_mean")
  #EndIf

  #If ( SENSOR_HMP = TRUE ) Then
    Sample(1,T_hmp_mean,FP2)              'mean HMP temp, degC
    Sample(1,RH_hmp_mean,FP2)             'mean HMP relative humidity, %
  #EndIf

  #If ( SENSOR_NR_LITE = TRUE ) Then
    Average (2,Rn,IEEE4,slowsequence_disable_f)
  #EndIf

  #If ( SENSOR_CS616 = TRUE ) Then
    Average (NMBR_CS616,soil_water_T(1),IEEE4,slowsequence_disable_f)
    Average (NMBR_CS616,cs616_wcr(1),IEEE4,slowsequence_disable_f)
  #EndIf

  #If ( SENSOR_HFT3 = TRUE ) Then
    Average (NMBR_SHF,shf(1),IEEE4,slowsequence_disable_f)
  #EndIf

  #If ( SENSOR_HFP01 = TRUE ) Then
    Average (NMBR_SHF,shf(1),IEEE4,slowsequence_disable_f)
  #EndIf

  #If ( SENSOR_HFP01SC = TRUE ) Then
    Average (NMBR_SHF,shf(1),IEEE4,shf_cal_on_f OR slowsequence_disable_f)
    Sample (NMBR_SHF,shf_cal(1),IEEE4)
  #EndIf

  #If ( SENSOR_190SB = TRUE ) Then
    Totalize (1,PAR_totflx,IEEE4,False)
    Average (1,PAR_flxdens,IEEE4,False)
  #EndIf

  #If ( SENSOR_034B = TRUE ) Then
    WindVector (1,WS_ms,WindDir,fp2,False,0,0,0)
    FieldNames("034b_ws2,034b_wd2,034b_stdwd2")
    Units 034b_ws2=m/s
    Units 034b_wd2=degrees
    Units 034b_stdwd2=degrees
  #EndIf
  
  #If ( SENSOR_TE525 = TRUE ) Then
    Totalize(1,Rain_mm,FP2,False)
  #EndIf

  'GARMIN GPS
  Sample(4,latitude_a,FP2)
  ' 2      latitude_b
  ' 3      longitude_a
  ' 4      longitude_b
  Sample(1,magnetic_variation,FP2)
  Sample(1,altitude,IEEE4)
  Sample(1,max_clock_change,IEEE4)
  Sample(1,nmbr_clock_change,UINT2)

  'DATALOGGER
  Average (1,panel_tmpr,FP2,FALSE)
  Average (1,batt_volt,FP2,slowsequence_disable_f)
EndTable







'*** Output data tables ***
DataTable (flux,TRUE,FLUX_SIZE_CPU)
  DataInterval (0,OUTPUT_INTERVAL,Min,10)
  CardOut (0,-1)

  

  #If ( SENSOR_EC150 = true ) Then
  '*** Beginning of CSAT3A sonic head output data ***
  Sample(1,l,ieee4)                         'monin obu length output
  Sample (18,Hs,IEEE4)
  Average (4,Ux,IEEE4,sonic_disable_f)
  Sample (1,sonic_azimuth,IEEE4)
  Totalize (1,n,IEEE4,sonic_disable_f)
  FieldNames ("sonic_samples_Tot")
  Totalize (1,n,IEEE4,diag_sonic<>-1)
  FieldNames ("no_sonic_head_Tot")
  Totalize (1,n,IEEE4,diag_sonic<>NAN)
  FieldNames ("no_new_sonic_data_Tot")
  Totalize (1,n,IEEE4,amp_l_f IMP (diag_sonic=NAN))
  FieldNames ("amp_l_f_Tot")
  Totalize (1,n,IEEE4,amp_h_f IMP (diag_sonic=NAN))
  FieldNames ("amp_h_f_Tot")
  Totalize (1,n,IEEE4,sig_lck_f IMP (diag_sonic=NAN))
  FieldNames ("sig_lck_f_Tot")
  Totalize (1,n,IEEE4,del_T_f IMP (diag_sonic=NAN))
  FieldNames ("del_T_f_Tot")
  Totalize (1,n,IEEE4,aq_sig_f IMP (diag_sonic=NAN))
  FieldNames ("aq_sig_f_Tot")
  Totalize (1,n,IEEE4,sonic_cal_err_f IMP (diag_sonic=NAN))
  FieldNames ("sonic_cal_err_f_Tot")
  '*** End of CSAT3A sonic head output data ***
  #EndIf

  #If ( SENSOR_EC150 = TRUE ) Then
  '*** Beginning of EC150 output data ***
  Sample (26,Fc_wpl,IEEE4)
  Totalize (1,n,IEEE4,irga_disable_f)
  FieldNames ("irga_samples_Tot")
  Totalize (1,n,IEEE4,diag_irga<>-1)
  FieldNames ("no_irga_head_Tot")
  Totalize (1,n,IEEE4,diag_irga<>NAN)
  FieldNames ("no_new_irga_data_Tot")
  Totalize (1,n,IEEE4,irga_bad_data_f IMP (diag_irga=NAN))
  FieldNames ("irga_bad_data_f_Tot")
  Totalize (1,n,IEEE4,gen_sys_fault_f IMP (diag_irga=NAN))
  FieldNames ("gen_sys_fault_f_Tot")
  Totalize (1,n,IEEE4,sys_startup_f IMP (diag_irga=NAN))
  FieldNames ("sys_startup_f_Tot")
  Totalize (1,n,IEEE4,motor_spd_f IMP (diag_irga=NAN))
  FieldNames ("motor_spd_f_Tot")
  Totalize (1,n,IEEE4,tec_tmpr_f IMP (diag_irga=NAN))
  FieldNames ("tec_tmpr_f_Tot")
  Totalize (1,n,IEEE4,src_pwr_f IMP (diag_irga=NAN))
  FieldNames ("src_pwr_f_Tot")
  Totalize (1,n,IEEE4,src_tmpr_f IMP (diag_irga=NAN))
  FieldNames ("src_tmpr_f_Tot")
  Totalize (1,n,IEEE4,src_curr_f IMP (diag_irga=NAN))
  FieldNames ("src_curr_f_Tot")
  Totalize (1,n,IEEE4,irga_off_f IMP (diag_irga=NAN))
  FieldNames ("irga_off_f_Tot")
  Totalize (1,n,IEEE4,irga_sync_f IMP (diag_irga=NAN))
  FieldNames ("irga_sync_f_Tot")
  Totalize (1,n,IEEE4,amb_tmpr_f IMP (diag_irga=NAN))
  FieldNames ("amb_tmpr_f_Tot")
  Totalize (1,n,IEEE4,amb_press_f IMP (diag_irga=NAN))
  FieldNames ("amb_press_f_Tot")
  Totalize (1,n,IEEE4,CO2_I_f IMP (diag_irga=NAN))
  FieldNames ("CO2_I_f_Tot")
  Totalize (1,n,IEEE4,CO2_Io_f IMP (diag_irga=NAN))
  FieldNames ("CO2_Io_f_Tot")
  Totalize (1,n,IEEE4,H2O_I_f IMP (diag_irga=NAN))
  FieldNames ("H2O_I_f_Tot")
  Totalize (1,n,IEEE4,H2O_Io_f IMP (diag_irga=NAN))
  FieldNames ("H2O_Io_f_Tot")
  Totalize (1,n,IEEE4,CO2_Io_var_f IMP (diag_irga=NAN))
  FieldNames ("CO2_Io_var_f_Tot")
  Totalize (1,n,IEEE4,H2O_Io_var_f IMP (diag_irga=NAN))
  FieldNames ("H2O_Io_var_f_Tot")
  Totalize (1,n,IEEE4,CO2_sig_strgth_f IMP (diag_irga=NAN))
  FieldNames ("CO2_sig_strgth_f_Tot")
  Totalize (1,n,IEEE4,H2O_sig_strgth_f IMP (diag_irga=NAN))
  FieldNames ("H2O_sig_strgth_f_Tot")
  Average (1,CO2_sig_strgth,IEEE4,irga_disable_f)
  FieldNames ("CO2_sig_strgth_mean")
  Average (1,H2O_sig_strgth,IEEE4,irga_disable_f)
  FieldNames ("H2O_sig_strgth_mean")
  '*** End of EC150 output data ***
  #EndIf

  
 

  

  #If ( SENSOR_HMP = TRUE ) Then
  '*** Beginning of HMP output data ***
  Sample (6,T_hmp_mean,IEEE4)
  '*** End of HMP output data ***
  #EndIf

  

  #If ( SENSOR_NR_LITE = TRUE ) Then
  '*** Beginning of NR Lite output data ***
  Average (2,Rn,IEEE4,slowsequence_disable_f)
  '*** End of NR Lite output data ***
  #EndIf

  #If ( SENSOR_CNR_2 = TRUE ) Then
  '*** Beginning of CNR_2 output data ***
  Average (3,Rn,IEEE4,slowsequence_disable_f)
  '*** End of CNR 2 output data ***
  #EndIf

  #If ( SENSOR_NR_01_CNR_1 = TRUE ) Then
  '*** Beginning of NR 01/CNR 1 output data ***
  Average (9,Rn,IEEE4,slowsequence_disable_f)
  '*** End of NR 01/CNR 1 output data ***
  #EndIf

  #If ( SENSOR_CNR_4 = TRUE ) Then
  '*** Beginning of CNR 4 output data ***
  Average (9,Rn,IEEE4,slowsequence_disable_f)
  '*** End of CNR 4 output data ***
  #EndIf

  #If ( SENSOR_TCAV = TRUE ) Then
  '*** Beginning of TCAV output data ***
  Sample (NMBR_TCAV,Tsoil_mean(1),IEEE4)
  Sample (NMBR_TCAV,del_Tsoil(1),IEEE4)
  '*** End of TCAV output data ***
  #EndIf

  #If ( SENSOR_CS616 = TRUE ) Then
  '*** Beginning of CS616 output data ***
  Average (NMBR_CS616,soil_water_T(1),IEEE4,slowsequence_disable_f)
  Average (NMBR_CS616,cs616_wcr(1),IEEE4,slowsequence_disable_f)
  '*** End of CS616 output data ***
  #EndIf

  #If ( SENSOR_HFT3 = TRUE ) Then
  '*** Beginning of HFT3 output data ***
  Average (NMBR_SHF,shf(1),IEEE4,slowsequence_disable_f)
  '*** End of HFT3 output data ***
  #EndIf

  #If ( SENSOR_HFP01 = TRUE ) Then
  '*** Beginning of HFP01 output data ***
  Average (NMBR_SHF,shf(1),IEEE4,slowsequence_disable_f)
  '*** End of HFP01 output data ***
  #EndIf

  #If ( SENSOR_HFP01SC = TRUE ) Then
  '*** Beginning of HFP01SC output data ***
  Average (NMBR_SHF,shf(1),IEEE4,shf_cal_on_f OR slowsequence_disable_f)
  Sample (NMBR_SHF,shf_cal(1),IEEE4)
  '*** End of HFP01SC output data ***
  #EndIf

  '*** Beginning of LI190SB output data ***
  Totalize (1,par_totflx,IEEE4,False)
  Average (1,par_flxdens,IEEE4,False)
  '*** End of LI190SB output data ***

  '*** Beginning of 034B output data ***
    WindVector (1,WS_ms,WindDir,fp2,False,0,0,0)
    FieldNames("034b_ws,034b_wd,034b_stdwd")
    Units 034b_ws=m/s
    Units 034b_wd=degrees
    Units 034b_stdwd=degrees
    
  '*** End of 034B output data ***
  
 

  '*** Beginning of TE525 output data ***
  Totalize(1,Rain_mm,FP2,False)
  '*** End of TE525 output data ***

  '*** Beginning of GPS16X-HVS output data ***
  Sample (15,gps_data,IEEE4)
  '*** End of GPS16X-HVS output data ***


  '*** Beginning of other output data ***
  Average (1,panel_tmpr,IEEE4,FALSE)
  Average (1,batt_volt,IEEE4,slowsequence_disable_f)
  '*** End of other output data ***

  Totalize (1,n,IEEE4,slowsequence_disable_f)
  FieldNames ("slowsequence_Tot")
EndTable


'Time series data.
DataTable (ts_data,TRUE,-1)
  DataInterval (0,SCAN_INTERVAL,mSec,100)
  CardOut (0,-1)

  '*** Beginning of CSAT3(A) time series output ***
  Sample (3,sonic_irga_raw(1),IEEE4)
  FieldNames ("Ux,Uy,Uz")
  Units Ux = m/s
  Units Uy = m/s
  Units Uz = m/s
  Sample(2,sonic_irga_raw(4),ieee4)
  FieldNames ("Ts,diag_sonic")
  Units Ts = C
  Units diag_sonic = arb  
 'WindVector (1,Uy,Ux,IEEE4,sonic_disable_f,0,1,0)
'*** End of CSAT3(A) time series output ***
 
 
 
 #If ( SENSOR_EC150 = TRUE ) Then
  '*** Beginning of EC150 time series output ***
  co2_molar_density=sonic_irga_raw(6)/44
  Sample(1,co2_molar_density,ieee4)
  FieldNames("co2_molar_density")
  Units co2_molar_density=umol/m^3
 
 h2o_molar_density=sonic_irga_raw(7)/.018
  Sample(1,h2o_molar_density,ieee4)
  FieldNames("h2o_molar_density")
  Units h2o_molar_density=mmol/m^3
  
  #If(sensor_n2o=true)Then
  Sample(1,n2o,fp2)
   Sample(1,c_monoxide,ieee4)
  #EndIf
  #If(sensor_ch4=true)Then
  Sample(1,ch4,fp2)
   Sample(1,co2_picarro,ieee4)
   #EndIf
  
 
  Sample (7,sonic_irga_raw(6),ieee4)
  FieldNames ("CO2,H2O,diag_irga,amb_tmpr,amb_press,CO2_sig_strgth,H2O_sig_strgth")
  Units CO2 = mg/m^3
  Units H2O = g/m^3
  Units diag_irga = arb
  Units amb_tmpr = C
  Units amb_press = kPa
  Units CO2_sig_strgth = arb
  Units H2O_sig_strgth = arb
  '*** End of EC150 time series output ***
  #EndIf
  
EndTable



'*** Program ***

BeginProg
    #If ( (SENSOR_HFT3 = TRUE) OR (SENSOR_HFP01 = TRUE) OR (SENSOR_HFP01SC = TRUE) ) Then
  'Load NMBR_SHF plate calibration.
  For i = 1 To NMBR_SHF
    Read shf_cal(i)
  Next i
  #EndIf

  sys_conf_var_file = FileOpen ("CPU:sys_conf_var.dat","rb",0) 'Check if a file exists.
  FileClose (sys_conf_var_file)

  If ( sys_conf_var_file = 0 ) Then
    Calfile (sonic_azimuth,1,"CPU:sys_conf_var.dat",0) 'Store the default values to the file.
  EndIf
  Calfile (sonic_azimuth,1,"CPU:sys_conf_var.dat",1) 'Read the values from the file.
  sonic_azimuth_prev = sonic_azimuth

  'Set the SDM clock speed.
  SDMSpeed (SDM_PER)
  Scan (SCAN_INTERVAL,mSec,SCAN_BUFFER_SIZE,0)
    'Datalogger panel temperature.
    PanelTemp (panel_tmpr,250)

   'Begin n2o/co measurements
   #If(sensor_n2o=true)Then
   VoltDiff(n2o,1,mv5000,6,true,0,250,.0001,0)
   VoltDiff(c_monoxide,1,mv5000,7,true,0,250,.0001,0)
   #EndIf
   
  'Begin ch2/co2 measurements
   #If(sensor_ch4=true)Then
   VoltDiff(ch4,1,mv5000,8,true,0,250,1,0)
   VoltDiff(co2_picarro,1,mv5000,9,true,0,250,1,0)
   #EndIf
    


    '*** Begining of 034B measurements ***
    PulseCount(WS_ms,1,1,2,1,0.799,0.2811)
    If WS_ms=0.2811 Then WS_ms=0
    BrHalf(WindDir,1,mV5000,WIND_034B_SE_INPUT,1,1,5000,True,0,_60Hz,720,0)
    If WindDir>=360 Then WindDir=0
    '*** End of 034B measurements ***

    '*** Begining of TE525 measurements ***
    PulseCount(Rain_mm,1,2,2,0,0.254,0)
    '*** End of TE525 measurements ***


    #If ( SENSOR_EC150 = TRUE ) Then
    '*** Beginning of EC150 w/ CSAT3A sonic head measurements ***
    'Get EC150 w/ CSAT3A sonic head data.
    EC100 (sonic_irga_raw(1),EC100_SDM_ADDR,1)

    If ( sonic_irga_raw(8) = NAN ) Then 'The EC150 diagnostic word (diag_irga) is sonic_irga_raw(8).
      NAN_cnt = NAN_cnt+1
      configure_ec100_f = FALSE
    Else
      If ( NAN_cnt > 4 ) Then ( configure_ec100_f = TRUE )
      NAN_cnt = 0
    EndIf

    If ( configure_ec100_f ) Then
      Call Config (config_array(1,1),3,configure_ec100_f)
    ElseIf ( set_press_source_f ) Then
      Call Config (press_source_array(1,1),1,set_press_source_f)
    ElseIf ( do_zero_f ) Then
      Call Config (zero_array(1,1),1,do_zero_f)
    ElseIf ( do_CO2_span_f ) Then
      span_CO2_array(1,2) = CO2_span_gas
      Call Config (span_CO2_array(1,1),2,do_CO2_span_f)
    ElseIf ( do_H2O_span_f )
      span_H2O_array(1,2) = Td_span_gas
      Call Config (span_H2O_array(1,1),2,do_H2O_span_f)
    EndIf

    CallTable delay_3d
    CallTable delay_cs
    '*** End of EC150 w/ CSAT3A sonic head measurements ***
    #EndIf
      
   

   

    #If ( SENSOR_CS616 = TRUE ) Then
    '*** Beginning of CS616 measurements ***
    CS616 (cs616_wcr(1),NMBR_CS616,CS616_ANALOG_INPUT,4,2,1,0)
    '*** End of CS616 measurements ***
    #EndIf


    #If ( (SENSOR_Q7_1 = TRUE) OR (SENSOR_NR_LITE = TRUE) ) Then
    hor_wind_raw = SQR (sonic_irga_raw(1)*sonic_irga_raw(1)+sonic_irga_raw(2)*sonic_irga_raw(2))
    AvgRun (hor_wind,1,hor_wind_raw,NMBR_WND_SAMPLES) 'Maintain a three second running mean of horizontal wind.
    #EndIf

    'Save time series data.
    CallTable ts_data

    If ( scan_count >= OFFSET ) Then
      


      #If ( SENSOR_EC150 = true ) Then
      '*** Beginning of CSAT3A sonic head processing ***
      'Load in CSAT3A sonic head data that has been lagged by EC150_REC_BCK scans.
      GetRecord (dly_data_out(1),delay_3d,EC150_REC_BCK)

      Move (Ux,5,dly_data_out(1),5) 'Ux, Uy, Uz, Ts, diag_sonic

      'Extract the six warning flags from the sonic diagnostic word.
      If ( (diag_sonic <> NAN) AND (diag_sonic <> -1) ) Then ( diag_sonic_tmp = diag_sonic ) Else ( diag_sonic_tmp = &h3f)
      mask = &h1
      For i = 1 To 6
        diag_bits_sonic(i) = diag_sonic_tmp AND mask
        mask = mask*2
      Next i

      'Turn on the intermediate processing disable flag when any CSAT3A sonic head
      'warning flag is high.
      sonic_disable_f = diag_sonic_tmp AND &h3f

      Ts_absolute = Ts+273.15

      'Load the arrays that hold the input data for the covariance instructions.
      cov_array_sonic(1,1) = Ts
      Move (cov_array_sonic(1,2),3,Ux,3)
      CallTable comp_cov_3d
      If ( comp_cov_3d.Output(1,1) ) Then
        GetRecord (Ts_stdev,comp_cov_3d,1)

        'Rotate the CSAT3A sonic head RHC system so the negative x-axis points north.
        wnd_dir_compass = (360+sonic_azimuth-wnd_dir_sonic) MOD 360

        'Make the CSAT3A sonic head wind direction fall between 0 to 180 degrees and 0 to -180 degrees.
        If ( wnd_dir_sonic > 180 ) Then ( wnd_dir_sonic = wnd_dir_sonic-360 )

        'Compute online fluxes.
        tau = SQR ((Ux_Uz_cov*Ux_Uz_cov)+(Uy_Uz_cov*Uy_Uz_cov))
        u_star = SQR (tau)
        
        l=-u_star^3*(Tc_mean+273.15)/(0.4*9.8*Ts_Uz_cov)   'obukohov length

        'Compute the standard deviation from the variance.
        Ts_stdev = SQR (Ts_stdev)
        Ux_stdev = SQR (Ux_stdev)
        Uy_stdev = SQR (Uy_stdev)
        Uz_stdev = SQR (Uz_stdev)
      EndIf
      '*** End of CSAT3A sonic head processing ***
      #EndIf


      '*** Beginning of EC150 processing ***
      #If ( SENSOR_EC150 = TRUE ) Then
      'Load in the EC150 data that has been lagged by EC150_REC_BCK scans.
      GetRecord (dly_data_out(1),delay_cs,EC150_REC_BCK)

      Move (CO2,7,dly_data_out(1),7) 'CO2, H2O, diag_irga, amb_tmpr, amb_press, CO2_sig_strgth, H2O_sig_strgth

      'Compute the EC150 dew point temperature from the H2O density at atmospheric pressure and shroud temperature.
      Td_tmp = LOG (H2O*R*(amb_tmpr+273.15)/(11.0178*(1.00072+3.2e-5*amb_press+5.9e-9*amb_press*amb_tmpr*amb_tmpr))) 'Td_tmp = ln (H2O*R*(T+273.15)/(Mv*0.61121*f)); Mv = 18 g/mol, f = 1.00072+3.2e-5*P+5.9e-9*P*T*T
      Td = (240.97*Td_tmp)/(17.502-Td_tmp) 'Buck (1981) Eq. (2a, 3a, & 6) and Leuning (2004) Eq. (6.23)

      'Extract the twenty one flags from the gas analyzer diagnostic word.
      If ( (diag_irga <> NAN) AND (diag_irga <> -1) ) Then ( diag_irga_tmp = diag_irga ) Else ( diag_irga_tmp = &h1fffff)
      mask = &h1
      For i = 1 To 21
        diag_bits_irga(i) = diag_irga_tmp AND mask
        mask = mask*2
      Next i

      'Compute fast response air temperature from sonic temperature and EC150 vapor density.
      Tc = Ts_absolute/(1+0.32*H2O*R*Ts_absolute/(amb_press*18)) 'Kaimal and Gaynor (1991) Eq. (3).

      'Convert the fast response air temperature to degrees C.
      Tc = Tc-273.15
      
      'Compute the molar mixing ratio of CO2 and H2O.
      divisor = (amb_press/(R*(Tc+273.15)))-(H2O/18)
      Xc=CO2/(0.044*divisor)
      Xv=H2O/(0.018*divisor)

      
      co2_mix_ratio = sonic_irga_raw(6)/44*R*Tc/amb_press*1000
      h2o_mix_ratio = sonic_irga_raw(7)/0.018*R*Tc/amb_press

      
      'Filter data in the covariance instruction if the EC150 w/ CSAT3A sonic head reports bad data.
      irga_disable_f = sonic_disable_f OR irga_bad_data_f

      'Load the arrays that hold the input data for the covariance instructions.
      cov_array_cs(1,1) = CO2
      Move (cov_array_cs(1,2),3,Ux,3)
      cov_array_cs(2,1) = H2O
      Move (cov_array_cs(2,2),3,Ux,3)
      cov_array_cs(3,1) = Tc
      Move (cov_array_cs(3,2),3,Ux,3)
      CallTable comp_cov_cs
      If ( comp_cov_cs.Output(1,1) ) Then
        GetRecord (CO2_stdev,comp_cov_cs,1)

        rho_d_mean = (amb_press_mean/((Tc_mean+273.15)*RD))-(H2O_mean*MU_WPL)
        rho_a_mean = (rho_d_mean+H2O_mean)/1000

        'Compute online fluxes.
        Fc_irga = CO2_Uz_cov
        LE_irga = LV*H2O_Uz_cov

        'Compute the standard deviation from the variance.
        CO2_stdev = SQR (CO2_stdev)
        H2O_stdev = SQR (H2O_stdev)
        Tc_stdev = SQR (Tc_stdev)

        sigma_wpl = H2O_mean/rho_d_mean

        'EC150 Webb et al. (1980) term for carbon dioxide Eq. (24).
        CO2_wpl_LE = MU_WPL*CO2_mean/rho_d_mean*H2O_Uz_cov
        CO2_wpl_H = (1+(MU_WPL*sigma_wpl))*CO2_mean/(Tc_mean+273.15)*Tc_Uz_cov
        Fc_wpl = Fc_irga+CO2_wpl_LE+CO2_wpl_H

        'EC150 Webb et al. (1980) term for water vapor Eq. (25).
        H2O_wpl_LE = MU_WPL*sigma_wpl*LE_irga
        H2O_wpl_H = (1+(MU_WPL*sigma_wpl))*H2O_mean/(Tc_mean+273.15)*LV*Tc_Uz_cov
        LE_wpl = LE_irga+H2O_wpl_LE+H2O_wpl_H
      EndIf
      '*** End of EC150 processing ***
      #EndIf


      #If ( (SENSOR_HMP = TRUE) ) Then
      '*** Beginning of HMP processing ***
      CallTable stats_hmp
      If ( stats_hmp.Output(1,1) ) Then
        GetRecord (T_hmp_mean,stats_hmp,1)

        H2O_hmp_mean = e_hmp_mean/((T_hmp_mean+273.15)*RV)
        rho_d_mean_hmp = (SITE_PRESS-e_hmp_mean)/((T_hmp_mean+273.15)*RD)
        rho_a_mean_hmp = (rho_d_mean_hmp+H2O_hmp_mean)/1000
        RH_hmp_mean = 100*e_hmp_mean/e_sat_hmp_mean
      EndIf
      #EndIf


      

      #If ( (SENSOR_HMP = TRUE) AND (SENSOR_EC150 = TRUE) ) Then
      CallTable stats_hmp
      If ( stats_hmp.Output(1,1) ) Then
        H2O_hmp_mean = e_hmp_mean/((T_hmp_mean+273.15)*RV)
        rho_d_mean_hmp = (amb_press_mean-e_hmp_mean)/((T_hmp_mean+273.15)*RD)
        rho_a_mean_hmp = (rho_d_mean_hmp+H2O_hmp_mean)/1000
        RH_hmp_mean = 100*e_hmp_mean/e_sat_hmp_mean
      EndIf
      '*** End of HMP processing ***
      #EndIf

     
      
     
      'Compute the molar concentration of CO2 and H2O.
      'CO2_li_um_m = CO2_li/44*R*Tc_li/amb_press_li*1000
     ' H2O_li_mm_m = H2O_li/0.018*R*Tc_li/amb_press_li

         


      '*** Beginning of sonic sensible heat, momentum, and sensible heat flux processing ***
      If ( comp_cov_3d.Output(1,1) ) Then
        

        #If ( SENSOR_HMP = TRUE ) Then
        'CSAT3(A) sensible heat flux using sonic temperature.
        Hs = rho_a_mean_hmp*CP*Ts_Uz_cov       'Air density computed from HMP.

        'CSAT3(A) momentum flux.
        tau = rho_a_mean_hmp*tau               'Air density computed from HMP.
       
        #EndIf


               #If ( SENSOR_EC150 = TRUE ) Then
        'CSAT3(A) sensible heat flux using sonic temperature.
        Hs = rho_a_mean*CP*Ts_Uz_cov           'Air density computed from EC150.

        'CSAT3(A) momentum flux.
        tau = rho_a_mean*tau                   'Air density computed from EC150.

        'Sensible heat flux using sonic temperature corrected for water vapor measured by the EC150.
        Hc = rho_a_mean*CP*Tc_Uz_cov           'Air density computed from EC150.

        
        #EndIf
      EndIf
      '*** End of sensible heat flux processing ***



      #If ( SENSOR_TCAV = TRUE ) Then
      '*** Beginning of soil temperature processing ***
      CallTable soil_stat
      If ( soil_stat.Output(1,1) ) Then
        GetRecord (Tsoil_mean(1),soil_stat,1)

        'Compute the change in soil temperature.
        For i = 1 To NMBR_TCAV
          del_Tsoil(i) = Tsoil_mean(i)-prev_Tsoil(i)
          prev_Tsoil(i) = Tsoil_mean(i)
        Next i
      EndIf
      '*** End of soil temperature processing ***
      #EndIf

      CallTable flux
      CallTable CFNT_met_5min 
      slowsequence_disable_f = TRUE
      If ( slowsequence_finished_f ) Then
        slowsequence_finished_f = FALSE
        slowsequence_disable_f = FALSE
      EndIf
    Else
      scan_count = scan_count+1
    EndIf
  NextScan


  SlowSequence

  Scan (1,Sec,3,0)
    'Measure battery voltage.
    Battery (batt_volt)

    #If ( SENSOR_HMP = TRUE ) Then
    '*** Beginning of HMP measurements ***
    VoltDiff (T_hmp,1,mV1000,HMP_ANALOG_T_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)
    VoltDiff (RH_hmp,1,mV1000,HMP_ANALOG_RH_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)
    T_hmp = T_hmp*HMP_T_MULT+HMP_T_OFFSET
    RH_hmp = RH_hmp*0.1
    VaporPressure (e_hmp,T_hmp,RH_hmp)
    SatVP (e_sat_hmp,T_hmp)
    '*** End of HMP measurements ***
    #EndIf


    #If ( SENSOR_Q7_1 = TRUE ) Then
    '*** Beginning of Q7.1 measurements ***
    VoltDiff (Rn_meas,1,AutoRange,NR_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)

    'Apply calibration and wind correction to net radiometer measurement.
    If ( sonic_irga_raw(5) = 0 ) Then 'sonic_irga_raw(5) is the instantaneous CSAT3(A) diagnostic word.
      If (Rn_meas > 0) Then
        Rn_meas = Rn_meas*Q7_1_POS_CAL
        Rn = Rn_meas*(1+(0.0132*hor_wind)/(0.066+(0.2*hor_wind)))
      Else
        Rn_meas = Rn_meas*Q7_1_NEG_CAL
        Rn = Rn_meas*((0.00174*hor_wind)+0.99755)
      EndIf
    Else
      If (Rn_meas > 0) Then
        Rn_meas = Rn_meas*Q7_1_POS_CAL
        Rn = Rn_meas*1.045
      Else
        Rn_meas = Rn_meas*Q7_1_NEG_CAL
        Rn = Rn_meas
      EndIf
    EndIf
    '*** End of Q7.1 measurements ***
    #EndIf


    #If ( SENSOR_NR_LITE = TRUE ) Then
    '*** Beginning of NR Lite measurements ***
    VoltDiff (Rn_meas,1,AutoRange,NR_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,NRLITE_CAL,0)

    'Apply calibration and wind correction to net radiometer measurement.
    If ( sonic_irga_raw(5) = 0 ) Then 'sonic_irga_raw(5) is the instantaneous CSAT3(A) diagnostic word.
      Rn = Rn_meas*(1+(0.021286*(hor_wind-5)))
    Else
      Rn = Rn_meas
    EndIf
    '*** End of NR Lite measurements ***
    #EndIf


    #If ( SENSOR_CNR_2 = TRUE ) Then
    '*** Beginning of CNR 2 measurements ***
    VoltDiff (Rn_sw,2,AutoRange,NR_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)
    Rn_sw = Rn_sw*NR_SW_CAL
    Rn_lw = Rn_lw*NR_LW_CAL
    '*** End of CNR 2 measurements ***
    #EndIf


    #If ( SENSOR_NR_01_CNR_1 = TRUE ) Then
    '*** Beginning of NR 01/CNR 1 measurements ***
    VoltDiff (Rs_downwell,4,AutoRange,NR_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)
    Rs_downwell = Rs_downwell*NR_SW_DOWNWELL_CAL
    Rs_upwell = Rs_upwell*NR_SW_UPWELL_CAL
    Rl_downwell = Rl_downwell*NR_LW_DOWNWELL_CAL
    Rl_upwell = Rl_upwell*NR_LW_UPWELL_CAL

    Resistance (T_nr,1,mV200,T_NR_ANALOG_INPUT,Ix1,1,1675,TRUE,TRUE,0,ANALOG_INTEGRATION,1,0)
    T_nr = T_nr/100
    PRT (T_nr,1,T_nr,1,273.15)

    'Compute net radiation, albedo, downwelling and upwelling longwave radiation.
    Rn = Rs_downwell-Rs_upwell+Rl_downwell_meas-Rl_upwell_meas
    albedo = Rs_upwell/Rs_downwell
    Rl_downwell = Rl_downwell_meas+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
    Rl_upwell = Rl_upwell_meas+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
    '*** End of NR 01/CNR 1 measurements ***
    #EndIf


    #If ( SENSOR_CNR_4 = TRUE ) Then
    '*** Beginning of CNR 4 measurements ***
    VoltDiff (Rs_downwell,4,AutoRange,NR_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)
    Rs_downwell = Rs_downwell*NR_SW_DOWNWELL_CAL
    Rs_upwell = Rs_upwell*NR_SW_UPWELL_CAL
    Rl_downwell = Rl_downwell*NR_LW_DOWNWELL_CAL
    Rl_upwell = Rl_upwell*NR_LW_UPWELL_CAL

    BrHalf (X_cnr4,1,AutoRange,T_NR_ANALOG_INPUT,Vx1,1,5000,TRUE,0,ANALOG_INTEGRATION,1,0)
    ln_R = LOG (1000*X_cnr4/(1-X_cnr4))
    T_nr = (1/(A_SHH+B_SHH*ln_R+C_SHH*ln_R*ln_R*ln_R))+273.15

    'Compute net radiation, albedo, downwelling and upwelling longwave radiation.
    Rn = Rs_downwell-Rs_upwell+Rl_down_meas-Rl_up_meas
    albedo = Rs_upwell/Rs_downwell
    Rl_downwell = Rl_down_meas+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
    Rl_upwell = Rl_up_meas+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
    '*** End of CNR 4 measurements ***
    #EndIf


    #If ( SENSOR_TCAV = TRUE ) Then
    '*** Beginning of TCAV measurements ***
    TCDiff (Tsoil(1),NMBR_TCAV,AutoRange,TCAV_ANALOG_INPUT,TypeE,panel_tmpr,TRUE,0,ANALOG_INTEGRATION,1,0)
    '*** End of TCAV measurements ***
    #EndIf


    #If ( SENSOR_CS616 = TRUE ) Then
    '*** Beginning of CS616 measurement processing ***
    'Apply temperature correction to CS616 period and find volumetric water content.
    For ii = 1 To NMBR_TCAV 'NMBR_TCAV must equal NMBR_CS616
      If ( (10 <= Tsoil(ii)) AND (Tsoil(ii) <= 40) ) Then
        cs616_T(ii) = cs616_wcr(ii)+(20-Tsoil(ii))*(0.526+cs616_wcr(ii)*(-0.052+cs616_wcr(ii)*0.00136))
      Else
        cs616_T(ii) = cs616_wcr(ii)
      EndIf
      soil_water_T(ii) = -0.0663+cs616_T(ii)*(-0.0063+cs616_T(ii)*0.0007)
    Next ii
    '*** End of CS616 measurement processing ***
    #EndIf


    #If ( SENSOR_HFT3 = TRUE ) Then
    '*** Beginning of HFT3 measurements ***
    VoltDiff (shf(1),NMBR_SHF,AutoRange,SHF_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,shf_cal(),0)
    '*** End of HFT3 measurements ***
    #EndIf


    #If ( SENSOR_HFP01 = TRUE ) Then
    '*** Beginning of HFP01SC measurements ***
    VoltDiff (shf(1),NMBR_SHF,AutoRange,SHF_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,shf_cal(),0)
    '*** End of HFP01SC measurements ***
    #EndIf


    #If ( SENSOR_HFP01SC = TRUE ) Then
    '*** Beginning of HFP01SC measurements ***
    VoltDiff (shf_mV(1),NMBR_SHF,AutoRange,SHF_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)

    'Apply HFP01SC soil heat flux plate calibration.
    For ii = 1 To NMBR_SHF
      shf(ii) = shf_mV(ii)*shf_cal(ii)
    Next ii

    'Power the HFP01SC heaters.
    PortSet (9,sw12_1_state)

    'Measure voltage across the heater (V_Rf).
    VoltSe (V_Rf(1),NMBR_SHF,mV5000,SHF_HEATER_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)

    'Maintain filtered values for calibration.
    AvgRun (shf_mV_run(1),NMBR_SHF,shf_mV(1),10)
    AvgRun (V_Rf_run(1),NMBR_SHF,V_Rf(1),10)

    'Begin HFP01SC calibration one minute into very CAL_INTERVAL minutes.
    If ( IfTime (1,CAL_INTERVAL,Min) ) Then
      shf_cal_on_f = TRUE
      Move (shf_mV_0(1),NMBR_SHF,shf_mV_run(1),NMBR_SHF)
      sw12_1_state = TRUE
    EndIf

    If ( IfTime (4,CAL_INTERVAL,Min) ) Then
      Move (shf_mV_180(1),NMBR_SHF,shf_mV_run(1),NMBR_SHF)
      Move (V_Rf_180(1),NMBR_SHF,V_Rf_run(1),NMBR_SHF)
      sw12_1_state = FALSE
    EndIf

    'End HFP01SC calibration sequence.
    If ( IfTime (END_CAL,CAL_INTERVAL,Min) ) Then
      Move (shf_mV_end(1),NMBR_SHF,shf_mV_run(1),NMBR_SHF)
      'Compute new HFP01SC calibration factors.
      For ii = 1 To NMBR_SHF
        shf_cal(ii) = V_Rf_180(ii)*V_Rf_180(ii)*128.7/ABS (((shf_mV_0(ii)+shf_mV_end(ii))/2)-shf_mV_180(ii))
      Next ii
      shf_cal_on_f = FALSE
    EndIf
    '*** End of HFP01SC measurements ***
    #EndIf

    '*** Beginning of LI190SB measurements ***
    VoltDiff (par_mV,1,mV20,PAR_ANALOG_INPUT,True,200,250,1.0,0)

    'Calculate Flux Density & Total Flux
    par_flxdens = par_mV*par_mult_flxdens
    par_totflx = par_mV*par_mult_totflx
    '*** End of LI190SB measurements ***

    '*** Beginning of GPS16X-HVS measurements ***

    '*** End of GPS16X-HVS measurements ***
    GPS (latitude_a,Com4,LOCAL_TIME_OFFSET*3600,0,nmea_sentence(1))
    'Update file if sonic azimuth has changed.
    If ( sonic_azimuth_prev <> sonic_azimuth ) Then
      sonic_azimuth_prev = sonic_azimuth
      Calfile (sonic_azimuth,1,"CPU:sys_conf_var.dat",0)  'Store the new value to the file.
    EndIf

    slowsequence_finished_f = TRUE
  NextScan
EndProg
